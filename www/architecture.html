<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <meta name="verify-v1" content="g222frIIxcQTrvDR3NBRUSKP3AnMNoqxOkIniCEkV7U=" />
  <link rel="meta" type="application/rdf+xml" title="ICI" href="http://imagemagick.org/ici.rdf" />
  <style type="text/css" media="all">
    @import url("../www/magick.css");
  </style>
  <link rel="shortcut icon" href="../images/wand.ico"  type="images/vnd.microsoft.icon"/>
  <title>ImageMagick: Architecture</title>
  <meta http-equiv="Content-Language" content="en-US"/>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta http-equiv="Reply-to" content="magick-users@imagemagick.org"/>
  <meta name="Generator" content="PHP"/>
  <meta name="Keywords" content="architecture, ImageMagick, ImageMagic, MagickCore, MagickWand, PerlMagick, Magick++, RMagick, PythonMagick, JMagick, TclMagick, Image, Magick, Magic, Wand, ImageMagickObject, Swiss, Army, Knife, Image, Processing"/>
  <meta name="Description" content="ImageMagick® is a software suite to create, edit, and compose bitmap images. It can read, convert and write images in a variety of formats (about 100) including GIF, JPEG, JPEG-2000, PNG, PDF, PhotoCD, TIFF, and DPX. Use ImageMagick to translate, flip, mirror, rotate, scale, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses and Bézier curves.  ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you can freely use, copy, modify, and distribute. Its license is compatible with the GPL. It runs on all major operating systems.  The functionality of ImageMagick is typically utilized from the command line or you can use the features from programs written in your favorite programming language. Choose from these interfaces: MagickCore (C), MagickWand (C), ChMagick (Ch), Magick++ (C++), JMagick (Java), L-Magick (Lisp), PascalMagick (Pascal), PerlMagick (Perl), MagickWand for PHP (PHP), PythonMagick (Python), RMagick (Ruby), or TclMagick (Tcl/TK). With a language interface, use ImageMagick to modify or create images automagically and dynamically."/>
  <meta name="Rating" content="GENERAL"/>
  <meta name="Robots" content="INDEX, FOLLOW"/>
  <meta name="Generator" content="ImageMagick Studio LLC"/>
  <meta name="Author" content="ImageMagick Studio LLC"/>
  <meta name="Revisit-after" content="2 DAYS"/>
  <meta name="Resource-type" content="document"/>
  <meta name="Copyright" content="Copyright (c) 1999-2010 ImageMagick Studio LLC"/>
  <meta name="Distribution" content="Global"/>
</head>

<body id="www-imagemagick-org">
<div class="titlebar">
<a href="../index.html">
  <img src="../images/script.png" alt="[ImageMagick]"
  style="width: 350px; height: 60px; margin: 28px auto; float: left;" /></a>
<a href="http://www.networkredux.com">
  <img src="../images/networkredux.png" alt="[sponsor]"
  style="margin: 45px auto; border: 0px; float: left;" /></a>
<a href="http://www.imagemagick.org/discourse-server/">
  <img src="../images/logo.jpg" alt=""
  style="width: 114px; height: 118px; border: 0px; float: right;" /></a>
<a href="../index.html">
  <img src="../images/sprite.jpg" alt=""
  style="width: 114px; height: 118px; border: 0px; float: right;" /></a>
</div>

<div class="eastbar">

<div class="menu">
  <a title="About ImageMagick" href="../index.html">About ImageMagick</a>
</div>
<div class="sep"></div>
<div class="menu">
  <a title="Binary Releases" href="../www/binary-releases.html">Binary Releases</a>
</div>
<div class="sub">
    <a title="Binary Release: Unix" href="../www/binary-releases.html#unix">Unix</a>
</div>
<div class="sub">
    <a title="Binary Release: MacOS X" href="../www/binary-releases.html#macosx">Mac OS X</a>
</div>
<div class="sub">
    <a title="Binary Release: Windows" href="../www/binary-releases.html#windows">Windows</a>
</div>
<div class="sep"></div>
<div class="menu">
  <a title="Command-line Tools" href="../www/command-line-tools.html">Command-line Tools</a>
</div>
<div class="sub">
    <a title="Command-line Tools: Processing" href="../www/command-line-processing.html">Processing</a>
</div>
<div class="sub">
    <a title="Command-line Tools: Options" href="../www/command-line-options.html">Options</a>
</div>
<div class="sub">
    <a title="Command-line Tools: Usage" href="http://www.imagemagick.org/Usage/">Usage</a>
</div>
<div class="menu">
  <a title="Program Interfaces" href="../www/api.html">Program Interfaces</a>
</div>
<div class="sub">
    <a title="Program Interface: MagickWand" href="../www/magick-wand.html">MagickWand</a>
</div>
<div class="sub">
    <a title="Program Interface: MagickCore" href="../www/magick-core.html">MagickCore</a>
</div>
<div class="sub">
    <a title="Program Interface: PerlMagick" href="../www/perl-magick.html">PerlMagick</a>
</div>
<div class="sub">
    <a title="Program Interface: Magick++" href="../Magick++/">Magick++</a>
</div>
<div class="sep"></div>
<div  class="menu">
   <a title="Install from Source" href="../www/install-source.html">Install from Source</a>
</div>
<div class="sub">
    <a title="Install from Source: Unix" href="../www/install-source.html#unix">Unix</a>
</div>
<div class="sub">
    <a title="Install from Source: Windows" href="../www/install-source.html#windows">Windows</a>
 </div>
<div class="menu">
  <a title="Resources" href="../www/resources.html">Resources</a>
</div>
<div class="menu">
  <a title="Architecture" href="../www/architecture.html">Architecture</a>
</div>
<div class="menu">
  <a title="Download" href="../www/download.html">Download</a>
</div>
<div class="sep"></div>
<div class="menu">
  <a title="Search" href="http://www.imagemagick.org/script/search.php">Search</a>
</div>
<div class="sep"></div>
<div class="menu">
  <a title="Site Map"href="../www/sitemap.html">Site Map</a>
</div>
<div  class="sub">
    <a title="Site Map: Links"href="../www/links.html">Links</a>
</div>
<div class="sep"></div>
<div  class="menu">
  <a title="Sponsors" href="../www/sponsors.html">Sponsors:</a>

<div class="sponsbox">
<div  class="sponsor">
  <a title="Sponsor: Webdesign Agentur" href="http://www.ventzke-partner.de">Webdesign Agentur</a><!-- 201101010480 invendio.de-->
</div>
<div  class="sponsor">
  <a title="Sponsor: LVM Versicherung" href="http://www.neu-reich.de">LVM Versicherung</a><!-- 201101010480 -->
</div>
<div  class="sponsor">
  <a title="Sponsor: Deko.net" href="http://www.deko.net">Deko.net</a><!-- 201101010600 Peterssen-->
</div>
<div  class="sponsor">
  <a title="Sponsor: Kredit" href="http://www.online-kredit-index.de">Kredit</a><!-- 201007010120 Buchhorn -->
</div>
<div  class="sponsor">
  <a title="Sponsor: Druckerei" href="http://www.print24.de/">Druckerei</a><!-- 201009010720 -->
</div>
<div  class="sponsor">
   <a title="Sponsor: Druckerei Online" href="http://www.allesdruck.de">Druckerei Online</a><!-- 201012011200 allesdruck.de-->
</div>
<div  class="sponsor">
   <a title="Sponsor: Lampe Berger" href="http://www.geschenke-elsen.de/" title="Lampe Berger">Lampe Berger</a><!-- 20106101000040 -->
</div>
</div>
</div>


</div>

<div class="main">



<p class="navigation-index">[<a href="#overview">Architecture Overview</a> &bull; <a href="#cache">The Pixel Cache</a> &bull; <a href="#stream">Streaming Pixels</a> &bull; <a href="#properties">Image Properties and Profiles</a> &bull; <a href="#tera-pixel">Large Image Support</a> &bull; <a href="#threads">Threads of Execution</a> &bull; <a href="#distributed">Heterogeneous Distributed Processing</a> &bull; <a href="#coders">Custom Image Coders</a> &bull; <a href="#filters">Custom Image Filters</a>]</p>

<div class="doc-section">
<p>The citizens of Oz were quite content with their benefactor, the all-powerful Wizard.  They accepted his wisdom and benevolence without ever questioning the who, why, and where of his power.  Like the citizens of Oz, if you feel comfortable that ImageMagick can help you convert, edit, or compose your images without knowing what goes on behind the curtain, feel free to skip this section.  However, if you want to know more about the software and algorithms behind ImageMagick, read on.  To fully benefit from this discussion, you should be comfortable with image nomenclature and be familiar with computer programming.</p>
</div>

<h2><a name="overview"></a>Architecture Overview</h2>
<div class="doc-section">

<p>An image typically consists of a rectangular region of pixels and metadata.  To convert, edit, or compose an image in an efficient manner we need convenient access to any pixel anywhere within the region (and sometimes outside the region).  And in the case of an image sequence, we need access to any pixel of any region of any image in the sequence.  However, there are hundreds of image formats such JPEG, TIFF, PNG, GIF, etc., that makes it difficult to access pixels on demand.  Within these formats we find differences in:</p>

<ul>
  <li>colorspace (e.g RGB, CMYK, YUV, Lab, etc.)</li>
  <li>bit depth (.e.g 1, 4, 8, 12, 16, etc.)</li>
  <li>storage format (e.g. unsigned, signed, float, double, etc.)</li>
  <li>compression (e.g. uncompressed, RLE, Zip, BZip, etc.)</li>
  <li>orientation (i.e. top-to-bottom, right-to-left, etc.),</li>
  <li>layout (.e.g. raw, interspersed with opcodes, etc.)</li>
</ul>

<p>In addition, some image pixels may require attenuation, some formats permit more than one frame, and some formats contain vector graphics that must first be rasterized (converted from vector to pixels).</p>

<p>An efficient implementation of an image processing algorithm may require we get or set:</p>

<ul>
  <li>one pixel a time (e.g. pixel at location 10,3)</li>
  <li>a single scanline (e.g. all pixels from row 4)</li>
  <li>a few scanlines at once (e.g. pixel rows 4-7)</li>
  <li>a single column or columns of pixels (e.g. all pixels from column 11)</li>
  <li>an arbitrary region of pixels from the image (e.g. pixels defined at 10,7 to 10,19)</li>
  <li>a pixel in random order (e.g. pixel at 14,15 and 640,480)</li>
  <li>pixels from two different images (e.g. pixel at 5,1 from image 1 and pixel at 5,1 from image 2)</li>
  <li>pixels outside the boundaries of the image (e.g. pixel at -1,-3)</li>
  <li>a pixel component that is unsigned or in a floating-point representation (e.g. 0.17836)</li>
  <li>a high-dynamic range pixel that can include negative values as well as values that exceed the quantum depth (e.g. -0.00716)</li>
  <li>one or more pixels simultaneously in different threads of execution</li>
  <li>all the pixels in memory to take advantage of speed-ups offered by executing in concert across heterogeneous platforms consisting of CPUs, GPUs, and other processors</li>
</ul>

<p>In addition, some images include a clip mask that define which pixels are eligible to be updated.  Pixels outside the area defined by the clip mask remain untouched.</p>

<p>Given the varied image formats and image processing requirements, we implemented the ImageMagick <a href="#cache">pixel cache</a> to provide convenient sequential or parallel access to any pixel on demand anywhere inside the image region (we call these <a href="#authentic-pixels">authentic pixels</a>)  and from any image in a sequence.  In addition, the pixel cache permits access to pixels outside the boundaries defined by the image (we call these <a href="#virtual-pixels">virtual pixels</a>).</p>

<p>In addition to pixels, images have a plethora of <a href="#properties">image properties and profiles</a>.  Properties include the well known attributes such as width, height, depth, and colorspace.  An image may have optional properties which might include the image author, a comment, a create date, and others.  Some images also include profiles for color management, or EXIF, IPTC, 8BIM, or XMP informational profiles.  ImageMagick provides command line options and programming methods to get, set, or view image properties or profiles or apply profiles.</p>

<p>ImageMagick consists of more than 400,000 lines of C code and optionally depends on several million lines of code in dependent libraries (e.g. JPEG, PNG, TIFF libraries).  Given that, one might expect a huge architecture document.  However, a great majority of image processing is simply accessing pixels and its metadata and our simple and elegant implementation makes this easy for the ImageMagick developer.  We discuss the implementation of the pixel cache and getting and setting image properties and profiles in the next few sections. Next, we discuss using ImageMagick within a <a href="#threads">thread</a> of execution.  In the final sections, we discuss <a href="#coders">image coders</a> to read or write a particular image format followed by a few words on creating a <a href="#filters">filter</a> to access or update pixels based on your custom requirements.</p>

</div>

<h2><a name="cache"></a>The Pixel Cache</h2>
<div class="doc-section">

<p>The ImageMagick pixel cache is a repository for image pixels with up to 5 channels.  The first 4 channels are stored contiguously and an optional second area follows with 1 channel.  The channels are at the depth specified when ImageMagick was built.  The channel depths are 8 bits-per-pixel component for the Q8 version of ImageMagick, 16 bits-per-pixel component for the Q16 version, and 32 bits-per-pixel component for the Q32 version.  By default pixel components are unsigned quantities, however, if you use the <a href="../www/high-dynamic-range.html">high dynamic-range</a> version of ImageMagick, the components are 32-bit floating point. The primary 4 channels can hold any value but typically contain red, green, blue, and alpha intensities or cyan, magenta, yellow, and alpha intensities.  The optional fifth channel contains the colormap indexes for colormapped images or the black channel for CMYK images.  The pixel cache storage may be heap memory, anonymous memory mapped memory, disk-backed memory mapped, or on disk.  The pixel cache is reference-counted.  Only the cache properties are copied when the cache is cloned.  The cache pixels are subsequently copied when you signal your intention to update any of the pixels.</p>

<h3>Create the Pixel Cache</h3>
<div class="doc-section">

<p>The pixel cache is associated with an image when it is created and it is initialized when you try to get or put pixels.  Here are three common methods to associate a pixel cache with an image:</p>

<h4>Create an image canvas initialized to the background color:</h4>
<p class="code">
  image=AllocateImage(image_info);
  if (SetImageExtent(image,640,480) == MagickFalse)
    { /* an exception was thrown */ }
  (void) QueryMagickColor("red",&amp;image-&gt;background_color,&amp;image-&gt;exception);
  SetImageBackgroundColor(image);
</p>

<h4>Create an image from a JPEG image on disk:</h4>
<p class="code">  (void) strcpy(image_info-&gt;filename,"image.jpg"):
  image=ReadImage(image_info,exception);
  if (image == (Image *) NULL)
    { /* an exception was thrown */ }
</p>
<h4>Create an image from a memory based image:</h4>
<p class="code">
  image=BlobToImage(blob_info,blob,extent,exception);
  if (image == (Image *) NULL)
    { /* an exception was thrown */ }
</p>

<p>In our discussion of the pixel cache, we use the <a href="../www/magick-core.html">MagickCore API</a> to illustrate our points, however, the principles are the same for other program interfaces to ImageMagick.</p>

<p>When the pixel cache is initialized, pixels are scaled from whatever bit depth they originated from to that required by the pixel cache.  For example, a 1-channel 1-bit monochrome PBM image is scaled to a 4 channel 8-bit RGBA image, if you are using the Q8 version of ImageMagick, and 16-bit RGBA for the Q16 version.  You can determine which version you have with the <a href="../www/command-line-options.html#version">&#x2011;version</a> option: </p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>identify -version</span><span class='crtout'>Version: ImageMagick 6.6.2-0 2010-04-15 Q16 http://www.imagemagick.org</span></p>
<p>As you can see, the convenience of the pixel cache sometimes comes with a trade-off in storage (e.g. storing a 1-bit monochrome image as 16-bit RGBA is wasteful) and speed (i.e. storing the entire image in memory is generally slower than accessing one scanline of pixels at a time).  In most cases, the benefits of the pixel cache typically outweigh any disadvantages.</p>
</div>

<h3><a name="authentic-pixels"></a>Access the Pixel Cache</h3>
<div class="doc-section">

<p>Once the pixel cache is associated with an image, you typically want to get, update, or put pixels into it.  We refer to pixels inside the image region as <em>authentic pixels</em> and outside the region as <em>virtual pixels</em>.  Use these methods to access the pixels in the cache:</p>
<ul>
  <li><a href="../www/api/cache.html#GetVirtualPixels">GetVirtualPixels()</a> gets pixels that you do not intend to modify</li>
  <li><a href="../www/api/cache.html#GetAuthenticPixels">GetAuthenticPixels()</a> gets pixels that you intend to modify</li>
  <li><a href="../www/api/cache.html#QueueAuthenticPixels">QueueAuthenticPixels()</a> queue pixels that you intend to modify</li>
  <li><a href="../www/api/cache.html#SyncAuthenticPixels">SyncAuthenticPixels()</a> update the pixel cache with any modified pixels</li>
</ul>

<p>Here is a typical <a href="../www/magick-core.html">MagickCore</a> code snippet for manipulating pixels in the pixel cache.  In our example, we copy pixels from the input image to the output image and decrease the intensity by 10%:</p>

<div class="viewport">
<pre class="code">
  long
    x,
    y;

  const PixelPacket
    *p;

  PixelPacket
    *q;

  destination=CloneImage(source,source->columns,source->rows,MagickTrue,exception);
  if (destination  == (Image *) NULL)
    { /* an exception was thrown */ }
  for (y=0; y &lt; (long) source-&gt;rows; y++)
  {
    p=GetVirtualPixels(source,0,y,source-&gt;columns,1,exception);
    q=GetAuthenticPixels(destination,0,y,destination-&gt;columns,1,exception);
    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)
      break;
    for (x=0; x &lt; (long) source-&gt;columns; x++)
    {
      q-&gt;red=90*p-&gt;red/100;
      q-&gt;green=90*p-&gt;green/100;
      q-&gt;blue=90*p-&gt;blue/100;
      q-&gt;opacity=90*p-&gt;opacity/100;
      p++;
      q++;
    }
    if (SyncAuthenticPixels(destination,exception) == MagickFalse)
      break;
  }
  if (y &lt; (long) source-&gt;rows)
    { /* an exception was thrown */ }
</pre>
</div>

<p>When we first create the destination image by cloning the source image, the pixel cache pixels are not copied.  They are only copied when you signal your intentions to modify the pixel cache by calling <a href="../www/api/cache.html#GetAuthenticPixels">GetAuthenticPixels()</a> or <a href="../www/api/cache.html#QueueAuthenticPixels">QueueAuthenticPixels()</a>. Use <a href="../www/api/cache.html#QueueAuthenticPixels">QueueAuthenticPixels()</a> if you want to set new pixel values rather than update existing ones.  Finally, use <a href="../www/api/cache.html#SyncAuthenticPixels">SyncAuthenticPixels()</a> to ensure any updated pixels are pushed to the pixel cache.</p>

<p>Recall how we mentioned that the indexes of a colormapped image or the black channel of a CMYK image are stored separately.  Use  <a href="../www/api/cache.html#GetVirtualIndexes">GetVirtualIndexes()</a> (to read the indexes) or <a href="../www/api/cache.html#GetAuthenticIndexes">GetAuthenticIndexes()</a> (to update the indexes) to gain access to this channel.  For example, to print the colormap indexes, use:</p>

<pre class="code">
  const IndexPacket
    *indexes;

  for (y=0; y &lt; (long) source-&gt;rows; y++)
  {
    p=GetVirtualPixels(source,0,y,source-&gt;columns,1);
    if (p == (const PixelPacket *) NULL)
      break;
    indexes=GetVirtualIndexes(source);
    for (x=0; x &lt; (long) source-&gt;columns; x++)
      (void) printf("%d\n",indexes[x];
  }
  if (y &lt; (long) source-&gt;rows)
    /* an exception was thrown */
</pre>

<p>The pixel cache manager decides whether to give you direct or indirect access to the image pixels.  In some cases the pixels are staged to an intermediate buffer-- and that is why you must call SyncAuthenticPixels() to ensure this buffer is <em>pushed</em> out to the pixel cache to guarantee the corresponding pixels in the cache are updated.  For this reason we recommend that you only read or update a scanline or a few scanlines of pixels at a time.  However, you can get any rectangular region of pixels you want.  GetAuthenticPixels() requires that the region you request is within the bounds of the image area.  For a 640 by 480 image, you can get a scanline of 640 pixels at row 479 but if you ask for a scanline at row 480, an exception is returned (rows are numbered starting at 0).  GetVirtualPixels() does not have this constraint.  For example,</p>

<pre class="code">
  p=GetVirtualPixels(source,-3,3,source-&gt;columns+7,7,exception);
</pre>

<p>gives you the pixels you asked for without complaint, even though some are not within the confines of the image region.</p>
</div>

<h3><a name="virtual-pixels"></a>Virtual Pixels</h3>
<div class="doc-section">

 <p>Access to the virtual pixels are controlled by the <a href="../www/api/cache.html#SetImageVirtualPixelMethod">SetImageVirtualPixelMethod()</a> method from the MagickCore API or the <a href="../www/command-line-options.html#virtual-pixel">&#x2011;virtual&#x2011;pixel</a> option from the command line.  The methods include:</p>

<pre class="text">
  background:           the area surrounding the image is the background color
  black:                the area surrounding the image is black
  checker-tile:         alternate squares with image and background color
  dither:               non-random 32x32 dithered pattern
  edge:                 extend the edge pixel toward infinity
  gray:                 the area surrounding the image is gray
  horizontal-tile:      horizontally tile the image, background color above/below
  horizontal-tile-edge: horizontally tile the image and replicate the side edge pixels
  mirror:               mirror tile the image
  random:               choose a random pixel from the image
  tile:                 tile the image (default)
  transparent:          the area surrounding the image is transparent blackness
  vertical-tile:        vertically tile the image, sides are background color
  vertical-tile-edge:   vertically tile the image and replicate the side edge pixels
  white:                the area surrounding the image is white
</pre>

<p>There is a plethora of image processing algorithms that require a neighborhood of pixels about a pixel of interest.  There is typically a caveat concerning how to handle pixels around the image boundaries, known as edge pixels.  With virtual pixels, you do not need to concern yourself about special edge processing other than choosing  which virtual pixel method is most appropriate for your algorithm.</p>
</div>

<h3>Cache Storage and Resource Requirements</h3>
<div class="doc-section">

<p>Recall that this simple and elegant design of the ImageMagick pixel cache comes at a cost in terms of storage and processing speed.  The pixel cache storage requirements scales with the area of the image and the bit depth of the pixel components.  For example, if we have a 640 by 480 image and we are using the Q16 version of ImageMagick, the pixel cache consumes image <em>width * height * bit-depth / 8 * channels</em> bytes or approximately 2.3 mebibytes (i.e. 640 * 480 * 2 * 4).  Not too bad, but what if your image is 25000 by 25000 pixels?  The pixel cache requires approximately 4.7 gibibytes of storage.  Ouch.  ImageMagick accounts for possible huge storage requirements by caching large images to disk rather than memory.  Typically the pixel cache is stored in memory using heap memory. If heap memory is exhausted, pixels are stored in in an anonymous map; if the anonymous memory map is exhausted, we create the pixel cache on disk and attempt to memory-map it; and if memory-map memory is exhausted, we simply use standard disk I/O.  Disk storage is cheap but it is also very slow, upwards of 1000 times slower than memory.  We can get some speed improvements, up to 5 times, if we use memory mapping to the disk-based cache.  These decisions about storage are made <em>automagically</em> by the pixel cache manager negotiating with the operating system.  However, you can influence how the pixel cache manager allocates the pixel cache with <em>cache resource limits</em>.  The limits include:</p>

<dl class="doc">
  <dt class="doc">files</dt>
  <dd>maximum number of open pixel cache files.  When this limit is exceeded, any subsequent pixels cached to disk are closed and reopened on demand. This behavior permits a large number of images to be accessed simultaneously on disk, but with a speed penalty due to repeated open/close calls.</dd>
  <dt class="doc">area</dt>
  <dd>maximum area in bytes of any one image that can reside in the pixel cache memory.  If this limit is exceeded, the image is automagically cached to disk.</dd>
  <dt class="doc">memory</dt>
  <dd>maximum amount of memory in bytes to allocate for the pixel cache from the anonymous mapped memory or the heap.</dd>
  <dt class="doc">map</dt>
  <dd>maximum amount of memory map in bytes to allocate for the pixel cache.</dd>
  <dt class="doc">disk</dt>
  <dd>maximum amount of disk space in bytes permitted for use by the pixel cache.  If this limit is exceeded, the pixel cache is not created and a fatal exception is thrown.</dd>
</dl>

<p>To determine the current setting of these limits, use this command:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>identify -list resource</span><span class='crtout'><pre>File         Area       Memory          Map         Disk    Thread         Time
-------------------------------------------------------------------------------
 768     12.443GB    8.6917GiB    23.178GiB  18.446744EB         8    unlimited</pre></span></p>
<p>You can set these limits either with  <a href="../www/resources.html#environment">environment variables</a>, the <a href="../www/command-line-options.html#limit">-limit</a> command line option, or the <a href="../www/api/resource.html#SetMagickResourceLimit">SetMagickResourceLimit()</a> MagickCore API method. As an example, our online web interface to ImageMagick, <a href="http://www.imagemagick.org/MagickStudio/scripts/MagickStudio.cgi">ImageMagick Studio</a>, has an area limit of 64 megabytes, a memory limit of 128 mebibytes and a map limit of 256 mebibytes and a disk limit of 1 gigabytes.  Since we process multiple simultaneous sessions, we don't want any one session consuming all the available memory.  Instead large images are cached to disk.  If the image is too large and exceeds the pixel cache disk limit, the program exits.  In addition, we place a 60 second time limit to prevent any run-away processing tasks.</p>

<p>Note, the cache limits are global, meaning if you create several images, the combined resource requirements are compared to the limit to determine the pixel cache storage disposition.</p>
</div>

<h3>Cache Views</h3>
<div class="doc-section">

<p>GetVirtualPixels(), GetAuthenticPixels(), QueueAuthenticPixels(), and SyncAuthenticPixels() from the MagickCore API can only deal with one pixel cache area per image at a time.  Suppose you want to access the first and last scanline from the same image at the same time?  The solution is to use a <em>cache view</em>.  A cache view permits you to access as many areas simultaneously in the pixel cache as you require.  The cache view <a href="../www/api/cache-view.html">methods</a> behave like the previous methods except you must first open a view and close it when you are finished with it. Here is a snippet of MagickCore code that permits us to access two areas of an image simultaneously:</p>

<pre class="code">
  CacheView
    *view_1,
    *view_2;

  view_1=OpenCacheView(source);
  view_2=OpenCacheView(source);
  for (y=0; y &lt; (long) source-&gt;rows; y++)
  {
    u=GetCacheViewVirtualPixels(view_1,0,y,source-&gt;columns,1,exception);
    v=GetCacheViewVirtualPixels(view_2,0,source-&gt;rows-y-1,source-&gt;columns,1,exception);
    if ((u == (const PixelPacket *) NULL) || (v == (const PixelPacket *) NULL))
      break;
    for (x=0; x &lt; (long) source-&gt;columns; x++)
    {
      /* do something with u &amp; v here */
    }
  }
  view_1=CloseCacheView(view_1);
  view_2=CloseCacheView(view_2);
  if (y &lt; (long) source-&gt;rows)
    { /* an exception was thrown */ }
</pre>
</div>

<h3>Magick Persistent Cache Format</h3>
<div class="doc-section">

<p>Recall that each image format is decoded by ImageMagick and the pixels are deposited in the pixel cache.  If you write an image, the pixels are read from the pixel cache and encoded as required by the format you are writing (e.g. GIF, PNG, etc.).  The Magick Persistent Cache (MPC) format is designed to eliminate the overhead of decoding and encoding pixels to and from an image format.  MPC writes two files.  One, with the extension <kbd>.mpc</kbd>, retains all the properties associated with the image or image sequence (e.g. width, height, colorspace, etc.) and the second, with the extension <kbd>.cache</kbd>, is the pixel cache in the native raw format.  When reading an MPC image file, ImageMagick reads the image properties and memory maps the pixel cache on disk eliminating the need for decoding the image pixels.  The tradeoff is in disk space.  MPC is generally larger in file size than most other image formats.</p>
</div>

<h3>Best Practices</h3>
<div class="doc-section">

<p>Although you can request any pixel from the pixel cache, any block of pixels, any scanline, multiple scanlines, any row, or multiple rows with the GetVirtualPixels(), GetAuthenticPixels(), QueueAuthenticPixels, GetCacheViewVirtualPixels(), GetCacheViewAuthenticPixels(), and QueueCacheViewAuthenticPixels() methods, ImageMagick is optimized to return a few pixels or a few pixels rows at time.  There are additional optimizations if you request a single scanline or a few scanlines at a time.  These methods also permit random access to the pixel cache, however, ImageMagick is optimized for sequential access.</p>

<p>If you update pixels returned from GetAuthenticPixels() or GetCacheViewAuthenticPixels(), don't forget to call SyncAuthenticPixels() or SyncCacheViewAuthenticPixels() respectively to ensure your changes are synchronized with the pixel cache.</p>

<p>Use QueueAuthenticPixels() or QueueCacheViewAuthenticPixels() if you are setting an initial pixel value.  The GetAuthenticPixels() or GetCacheViewAuthenticPixels() method reads pixels from the cache and if you are setting an initial pixel value, this read is unnecessary. Don't forget to call SyncAuthenticPixels() or SyncCacheViewAuthenticPixels() respectively to push your updates to the pixel cache.</p>

<p>GetVirtualPixels(), GetAuthenticPixels(), QueueAuthenticPixels(), and SyncAuthenticPixels() are slightly more efficient than their cache view counter-parts.  However, cache views are required if you need access to more than one region of the image simultaneously or if more than one <a href="#threads">thread of execution</a> is accessing the image.</p>

<p>You can request pixels outside the bounds of the image with GetVirtualPixels() or GetCacheViewVirtualPixels(), however, it is more efficient to request pixels within the confines of the image region.</p>

<p>Although you can force the pixel cache to disk using appropriate resource limits, disk access can be upwards of 1000 times slower than memory access.  For fast, efficient, access to the pixel cache, try to keep the pixel cache in heap memory or anonymous mapped memory.</p>

<p>The ImageMagick Q16 version of ImageMagick permits you to read and write 16 bit images without scaling but the pixel cache consumes twice as much resources as the Q8 version.  If your system has constrained memory or disk resources, consider the Q8 version of ImageMagick.  In addition, the Q8 version typically executes faster than the Q16 version.</p>

<p>A great majority of image formats and algorithms restrict themselves to a fixed range of pixel values from 0 to some maximum value, for example, the Q16 version of ImageMagick permit intensities from 0 to 65535.  High dynamic-range imaging (HDRI), however, permits a far greater dynamic range of exposures (i.e. a large difference between light and dark areas) than standard digital imaging techniques. HDRI accurately represents the wide range of intensity levels found in real scenes ranging from the brightest direct sunlight to the deepest darkest shadows.  Enable <a href="../www/high-dynamic-range.html">HDRI</a> at ImageMagick build time to deal with high dynamic-range images, but be mindful that each pixel component is a 32-bit floating point value. In addition, pixel values are not clamped by default so some algorithms may perform differently than the non-HDRI version.</p>

<p>If you are dealing with large images, make sure the pixel cache is written to a disk area with plenty of free space.  Under Unix, this is typically <kbd>/tmp</kbd> and for Windows, <kbd>c:/temp</kbd>.  You can tell ImageMagick to write the pixel cache to an alternate location with the MAGICK_TEMPORARY_PATH environment variable.  For example,</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>export MAGICK_TEMPORARY_PATH=/data/magick</span></p>

<p>If you plan on processing the same image many times, consider the MPC format.  Reading a MPC image has near-zero overhead because its in the native pixel cache format eliminating the need for decoding the image pixels.  Here is an example:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert image.tif image.mpc</span><span class='crtout'></span><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert image.mpc -crop 100x100+0+0 +repage 1.png</span><span class='crtout'></span><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert image.mpc -crop 100x100+100+0 +repage 2.png</span><span class='crtout'></span><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert image.mpc -crop 100x100+200+0 +repage 3.png</span></p>
<p>MPC is ideal for web sites.  It reduces the overhead of reading and writing an image.  We use it exclusively at our <a href="http://www.imagemagick.org/MagickStudio/scripts/MagickStudio.cgi">online image studio</a>.</p>
</div>

</div>

<h2><a name="stream"></a>Streaming Pixels</h2>
<div class="doc-section">

<p>ImageMagick provides for streaming pixels as they are read from or written to an image.  This has several advantages over the pixel cache.  The time and resources consumed by the pixel cache scale with the area of an image, whereas the pixel stream resources scale with the width of an image.  The disadvantage is the pixels must be consumed as they are streamed so there is no persistence.</p>

<p>Use <a href="../www/api/stream.html#ReadStream">ReadStream()</a> or <a href="../www/api/stream.html#WriteStream">WriteStream()</a> with an appropriate callback method in your MagickCore program to consume the pixels as they are streaming.  Here's an abbreviated example of using ReadStream:</p>

<pre class="code">
static size_t StreamHandler(const Image *image,const void *pixels,
  const size_t columns)
{
  /* process pixels here */
  return(columns);
}

...
/* invoke the pixel stream here */
image=ReadStream(image_info,&amp;StreamHandler,exception);
</pre>

<p>We also provide a lightweight tool, <a name="stream"></a><a href="../www/stream.html">stream</a>, to stream one or more pixel components of the image or portion of the image to your choice of storage formats.  It writes the pixel components as they are read from the input image a row at a time making <a name="stream"></a><a href="../www/stream.html">stream</a> desirable when working with large images or when you require raw pixel components.</p>

</div>

<h2><a name="properties"></a>Image Properties and Profiles</h2>
<div class="doc-section">

<p>Images have metadata associated with them in the form of properties (e.g. width, height, description, etc.) and profiles (e.g. EXIF, IPTC, color management).  ImageMagick provides convenient methods to get, set, or update image properties and get, set, update, or apply profiles.  Some of the more popular image properties are associated with the Image structure in the MagickCore API.  For example:</p>

<pre class="code">
  (void) printf("image width: %lu, height: %lu\n",image-&gt;columns,image-&gt;rows);
</pre>

<p>For a great majority of image properties, such as an image comment or description, we use the <a href="../www/api/property.html#GetImageProperty">GetImageProperty()</a> and <a href="../www/api/property.html#SetImageProperty">SetImageProperty()</a> methods.  Here we set a property and fetch it right back:</p>

<pre class="code">
  const char
    *comment;

  (void) SetImageProperty(image,"comment","This space for rent");
  comment=GetImageProperty(image,"comment");
  if (comment == (const char *) NULL)
    (void) printf("Image comment: %s\n",comment);
</pre>

<p>ImageMagick supports artifacts with the GetImageArtifact() and SetImageArtifact() methods.  Artifacts are stealth properties that are not exported to image formats (e.g. PNG) and they do not display when identifying an image.</p>

<p>Image profiles are handled with <a href="../www/api/profile.html#GetImageProfile">GetImageProfile()</a>, <a href="../www/api/profile.html#SetImageProfile">SetImageProfile()</a>, and <a href="../www/api/profile.html#ProfileImage">ProfileImage()</a> methods.  Here we set a profile and fetch it right back:</p>

<pre class="code">
  StringInfo
    *profile;

  profile=AcquireStringInfo(length);
  SetStringInfoDatum(profile,my_exif_profile);
  (void) SetImageProfile(image,"EXIF",profile);
  DestroyStringInfo(profile);
  profile=GetImageProfile(image,"EXIF");
  if (profile != (StringInfo *) NULL)
    (void) PrintStringInfo(stdout,"EXIF",profile);
</pre>

</div>

<h2><a name="tera-pixel"></a>Large Image Support</h2>
<div class="doc-section">
<p>ImageMagick can read, process, or write mega-, giga-, or tera-pixel image sizes.  For example, here we resize an image to a quarter million pixels square:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert logo: -resize 250000x250000 logo.miff</span></p>
<p>For large images, ImageMagick will more than likely create a pixel cache on disk.  Make sure you have plenty of temporary disk space.  If your default temporary disk partition is too small, tell ImageMagick to use another partition with plenty of free space.  For example:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert -define registry:temporary-path=/data/tmp logo:  \ <br/> -resize 250000x250000 logo.miff</span></p>
<p>To ensure large images do not consume all the memory on your system, force the image pixels to memory-mapped disk with resource limits:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert -define registry:temporary-path=/data/tmp -limit memory 16mb  \ <br/> logo: -resize 250000x250000 logo.miff</span></p>
<p>Here we force all image pixels to disk:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert -define registry:temporary-path=/data/tmp -limit area 0  \ <br/> logo: -resize 250000x250000 logo.miff</span></p>
<p>Caching pixels to disk is about 1000 times slower than memory.  Expect long run times when processing large images with ImageMagick.  You can monitor progress with this command:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert -monitor -define registry:temporary-path=/data/tmp -limit area 0  \ <br/> logo: -resize 250000x250000 logo.miff</span></p></div>

<h2><a name="threads"></a>Threads of Execution</h2>
<div class="doc-section">

<p>Many of ImageMagick's internal algorithms are threaded to take advantage of speed-ups offered by the dual and quad-core processor technologies. However, you are welcome to use ImageMagick algorithms in your threads of execution with the exception of the MagickCore's GetVirtualPixels(), GetAuthenticPixels(), QueueAuthenticPixels(), or SyncAuthenticPixels() pixel cache methods.  These methods are intended for one thread of execution only. To access the pixel cache with more than one thread of execution, use a cache view.  We do this for the <a href="../www/api/composite.html#CompositeImage">CompositeImage()</a> method, for example.  Suppose we want to composite a single image over a different image in each thread of execution.  If we use GetVirtualPixels(), the results are unpredictable because multiple threads would likely be asking for different areas of the pixel cache simultaneously.  Instead we use GetCacheViewVirtualPixels() which creates a unique view for each thread of execution ensuring our program behaves properly regardless of how many threads are invoked.  The other program interfaces, such as the <a href="../www/magick-wand.html">MagickWand API</a>, are completely thread safe so there are no special precautions for threads of execution.</p>

<p>Here is an example of how ImageMagick can take advantage of threads of execution with the <a href="http://en.wikipedia.org/wiki/OpenMP">OpenMP</a> programming paradigm:</p>

<div class="viewport">
<pre class="code">
{
  CacheView
    *image_view;

  long
    y;

  MagickBooleanType
    status;

  status=MagickTrue;
  image_view=AcquireCacheView(image);
  #pragma omp parallel for schedule(dynamic,4) shared(status)
  for (y=0; y &lt; (long) image-&gt;rows; y++)
  {
    register IndexPacket
      *indexes;

    register long
      x;

    register PixelPacket
      *q;

    if (status == MagickFalse)
      continue;
    q=GetCacheViewAuthenticPixels(image_view,0,y,image-&gt;columns,1,exception);
    if (q == (PixelPacket *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    indexes=GetCacheViewAuthenticIndexQueue(image_view);
    for (x=0; x &lt; (long) image-&gt;columns; x++)
    {
      q-&gt;red= ...
      q-&gt;green= ...
      q-&gt;blue= ...
      q-&gt;opacity= ...
      if (indexes != (IndexPacket *) NULL)
        indexes[x]= ...
      q++;
    }
    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
      status=MagickFalse;
  }
  image_view=DestroyCacheView(image_view);
  if (status == MagickFalse)
    perror("something went wrong");
}
</pre>
</div>

<p>If you call the ImageMagick API from your OpenMP-enabled application and you intend to dynamically increase the number of threads available in subsequent parallel regions, be sure to perform the increase <em>before</em> you call the API otherwise ImageMagick may fault.</p>

</div>

<h2><a name="distributed"></a>Heterogeneous Distributed Processing</h2>
<div class="doc-section">
<p>ImageMagick includes support for heterogeneous distributed processing with the <a href="http://en.wikipedia.org/wiki/OpenCL">OpenCL</a> framework.  OpenCL kernels within ImageMagick permit image processing algorithms to execute across heterogeneous platforms consisting of CPUs, GPUs, and other processors.  Depending on your platform, speed-ups can be an order of magnitude faster than the traditional single CPU.</p>

<p>First verify that your version of ImageMagick includes support for the OpenCL feature:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>identify -version</span><span class='crtout'>Features: OpenMP OpenCL</span></p>
<p>If so, run this command to realize a significant speed-up for image convolution:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert image.png convolve '-1, -1, -1, -1, 9, -1, -1, -1, -1'  \ <br/> convolve.png</span></p>
<p>If an accelerator is not available or if the accelerator fails to respond, ImageMagick reverts to the non-accelerated convolution algorithm.</p>

<p>Here is an example OpenCL kernel that convolves an image:</p>

<div class="viewport">
<pre class="code">
static inline long ClampToCanvas(const long offset,const ulong range)
{
  if (offset &lt; 0L)
    return(0L);
  if (offset >= range)
    return((long) (range-1L));
  return(offset);
}

static inline CLQuantum ClampToQuantum(const double value)
{
  if (value &lt; 0.0)
    return((CLQuantum) 0);
  if (value >= (double) QuantumRange)
    return((CLQuantum) QuantumRange);
  return((CLQuantum) (value+0.5));
}

__kernel void Convolve(const __global CLPixelType *source,__constant double *filter,
  const ulong width,const ulong height,__global CLPixelType *destination)
{
  const ulong columns = get_global_size(0);
  const ulong rows = get_global_size(1);

  const long x = get_global_id(0);
  const long y = get_global_id(1);

  const double scale = (1.0/QuantumRange);
  const long mid_width = (width-1)/2;
  const long mid_height = (height-1)/2;
  double4 sum = { 0.0, 0.0, 0.0, 0.0 };
  double gamma = 0.0;
  register ulong i = 0;

  for (long v=(-mid_height); v &lt;= mid_height; v++)
  {
    for (long u=(-mid_width); u &lt;= mid_width; u++)
    {
      register const ulong index=ClampToCanvas(y+v,rows)*columns+ClampToCanvas(x+u,columns);
      const double alpha=scale*(QuantumRange-source[index].w);
      sum.x+=alpha*filter[i]*source[index].x;
      sum.y+=alpha*filter[i]*source[index].y;
      sum.z+=alpha*filter[i]*source[index].z;
      sum.w+=filter[i]*source[index].w;
      gamma+=alpha*filter[i];
      i++;
    }
  }

  gamma=1.0/(fabs(gamma) &lt;= MagickEpsilon ? 1.0 : gamma);
  const ulong index=y*columns+x;
  destination[index].x=ClampToQuantum(gamma*sum.x);
  destination[index].y=ClampToQuantum(gamma*sum.y);
  destination[index].z=ClampToQuantum(gamma*sum.z);
  destination[index].w=ClampToQuantum(sum.w);
};
</pre>
</div>

<p>See <a href="http://trac.imagemagick.org/browser/ImageMagick/trunk/magick/accelerate.c">magick/accelerate.c</a> for a complete implementation of image convolution with an OpenCL kernel.</p>

</div>

<h2><a name="coders"></a>Custom Image Coders</h2>
<div class="doc-section">

<p>An image coder (i.e. encoder / decoder) is responsible for registering, optionally classifying, optionally reading, optionally writing, and unregistering one image format (e.g.  PNG, GIF, JPEG, etc.).  Registering an image coder alerts ImageMagick a particular format is available to read or write.  While unregistering tells ImageMagick the format is no longer available.  The classifying method looks at the first few bytes of an image and determines if the image is in the expected format.  The reader sets the image size, colorspace, and other properties and loads the pixel cache with the pixels.  The reader returns a single image or an image sequence (if the format supports multiple images per file), or if an error occurs, an exception and a null image.  The writer does the reverse.  It takes the image properties and unloads the pixel cache and writes them as required by the image format.</p>

<p>Here is a listing of a sample <a href="../www/source/mgk.c">custom coder</a>.  It reads and writes images in the MGK image format which is simply an ID followed by the image width and height followed by the RGB pixel values.</p>

<div class="viewport">
<pre class="code">
/*
  Include declarations.
*/
#include "magick/studio.h"
#include "magick/blob.h"
#include "magick/blob-private.h"
#include "magick/colorspace.h"
#include "magick/exception.h"
#include "magick/exception-private.h"
#include "magick/image.h"
#include "magick/image-private.h"
#include "magick/list.h"
#include "magick/magick.h"
#include "magick/memory_.h"
#include "magick/monitor.h"
#include "magick/monitor-private.h"
#include "magick/quantum-private.h"
#include "magick/static.h"
#include "magick/string_.h"
#include "magick/module.h"

/*
  Forward declarations.
*/
static MagickBooleanType
  WriteMGKImage(const ImageInfo *,Image *);

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   I s M G K                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  IsMGK() returns MagickTrue if the image format type, identified by the
%  magick string, is MGK.
%
%  The format of the IsMGK method is:
%
%      MagickBooleanType IsMGK(const unsigned char *magick,const size_t length)
%
%  A description of each parameter follows:
%
%    o magick: This string is generally the first few bytes of an image file
%      or blob.
%
%    o length: Specifies the length of the magick string.
%
*/
static MagickBooleanType IsMGK(const unsigned char *magick,const size_t length)
{
  if (length &lt; 7)
    return(MagickFalse);
  if (LocaleNCompare((char *) magick,"id=mgk",7) == 0)
    return(MagickTrue);
  return(MagickFalse);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   R e a d M G K I m a g e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  ReadMGKImage() reads a MGK image file and returns it.  It allocates
%  the memory necessary for the new Image structure and returns a pointer to
%  the new image.
%
%  The format of the ReadMGKImage method is:
%
%      Image *ReadMGKImage(const ImageInfo *image_info,ExceptionInfo *exception)
%
%  A description of each parameter follows:
%
%    o image_info: the image info.
%
%    o exception: return any errors or warnings in this structure.
%
*/
static Image *ReadMGKImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    buffer[MaxTextExtent];

  Image
    *image;

  long
    y;

  MagickBooleanType
    status;

  register long
    x;

  register PixelPacket
    *q;

  register unsigned char
    *p;

  ssize_t
    count;

  unsigned char
    *pixels;

  unsigned long
    columns,
    rows;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info-&gt;signature == MagickSignature);
  if (image_info-&gt;debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image_info-&gt;filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception-&gt;signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read MGK image.
  */
  (void) ReadBlobString(image,buffer);  /* read magic number */
  if (IsMGK(buffer,7) == MagickFalse)
    ThrowReaderException(CorruptImageError,"ImproperImageHeader");
  (void) ReadBlobString(image,buffer);
  count=(ssize_t) sscanf(buffer,"%lu %lu\n",&amp;columns,&amp;rows);
  if (count &lt;= 0)
    ThrowReaderException(CorruptImageError,"ImproperImageHeader");
  do
  {
    /*
      Initialize image structure.
    */
    image-&gt;columns=columns;
    image-&gt;rows=rows;
    image-&gt;depth=8;
    if ((image_info-&gt;ping != MagickFalse) &amp;&amp; (image_info-&gt;number_scenes != 0))
      if (image-&gt;scene >= (image_info-&gt;scene+image_info-&gt;number_scenes-1))
        break;
    /*
      Convert MGK raster image to pixel packets.
    */
    if (SetImageExtent(image,0,0) == MagickFalse)
      {
        InheritException(exception,&amp;image-&gt;exception);
        return(DestroyImageList(image));
      }
    pixels=(unsigned char *) AcquireQuantumMemory((size_t) image-&gt;columns,3UL*sizeof(*pixels));
    if (pixels == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
    for (y=0; y &lt; (long) image-&gt;rows; y++)
    {
      count=(ssize_t) ReadBlob(image,(size_t) (3*image-&gt;columns),pixels);
      if (count != (ssize_t) (3*image-&gt;columns))
        ThrowReaderException(CorruptImageError,"UnableToReadImageData");
      p=pixels;
      q=QueueAuthenticPixels(image,0,y,image-&gt;columns,1,exception);
      if (q == (PixelPacket *) NULL)
        break;
      for (x=0; x &lt; (long) image-&gt;columns; x++)
      {
        q-&gt;red=ScaleCharToQuantum(*p++);
        q-&gt;green=ScaleCharToQuantum(*p++);
        q-&gt;blue=ScaleCharToQuantum(*p++);
        q++;
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if ((image-&gt;previous == (Image *) NULL) &&
          (SetImageProgress(image,LoadImageTag,y,image&gt;>rows) == MagickFalse))
        break;
    }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",image-&gt;filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info-&gt;number_scenes != 0)
      if (image-&gt;scene >= (image_info-&gt;scene+image_info-&gt;number_scenes-1))
        break;
    *buffer='\0';
    (void) ReadBlobString(image,buffer);
    count=(ssize_t) sscanf(buffer,"%lu %lu\n",&amp;columns,&amp;rows);
    if (count != 0)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImageTag,TellBlob(image),GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (count != 0);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   R e g i s t e r M G K I m a g e                                           %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  RegisterMGKImage() adds attributes for the MGK image format to
%  the list of supported formats.  The attributes include the image format
%  tag, a method to read and/or write the format, whether the format
%  supports the saving of more than one frame to the same file or blob,
%  whether the format supports native in-memory I/O, and a brief
%  description of the format.
%
%  The format of the RegisterMGKImage method is:
%
%      unsigned long RegisterMGKImage(void)
%
*/
ModuleExport unsigned long RegisterMGKImage(void)
{
  MagickInfo
    *entry;

  entry=SetMagickInfo("MGK");
  entry-&gt;decoder=(DecodeImageHandler *) ReadMGKImage;
  entry-&gt;encoder=(EncodeImageHandler *) WriteMGKImage;
  entry-&gt;magick=(IsImageFormatHandler *) IsMGK;
  entry-&gt;description=ConstantString("MGK");
  entry-&gt;module=ConstantString("MGK");
  (void) RegisterMagickInfo(entry);
  return(MagickImageCoderSignature);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   U n r e g i s t e r M G K I m a g e                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  UnregisterMGKImage() removes format registrations made by the
%  MGK module from the list of supported formats.
%
%  The format of the UnregisterMGKImage method is:
%
%      UnregisterMGKImage(void)
%
*/
ModuleExport void UnregisterMGKImage(void)
{
  (void) UnregisterMagickInfo("MGK");
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W r i t e M G K I m a g e                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  WriteMGKImage() writes an image to a file in red, green, and blue
%  MGK rasterfile format.
%
%  The format of the WriteMGKImage method is:
%
%      MagickBooleanType WriteMGKImage(const ImageInfo *image_info,Image *image)
%
%  A description of each parameter follows.
%
%    o image_info: the image info.
%
%    o image:  The image.
%
*/
static MagickBooleanType WriteMGKImage(const ImageInfo *image_info,Image *image)
{
  char
    buffer[MaxTextExtent];

  long
    y;

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  register const PixelPacket
    *p;

  register long
    x;

  register unsigned char
    *q;

  unsigned char
    *pixels;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info-&gt;signature == MagickSignature);
  assert(image != (Image *) NULL);
  assert(image-&gt;signature == MagickSignature);
  if (image-&gt;debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image-&gt;filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&amp;image-&gt;exception);
  if (status == MagickFalse)
    return(status);
  scene=0;
  do
  {
    /*
      Allocate memory for pixels.
    */
    if (image-&gt;colorspace != RGBColorspace)
      (void) SetImageColorspace(image,RGBColorspace);
    pixels=(unsigned char *) AcquireQuantumMemory((size_t) image-&gt;columns,
      3UL*sizeof(*pixels));
    if (pixels == (unsigned char *) NULL)
      ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
    /*
      Initialize raster file header.
    */
    (void) WriteBlobString(image,"id=mgk\n");
    (void) FormatMagickString(buffer,MaxTextExtent,"%lu %lu\n",
      image-&gt;columns,image-&gt;rows);
    (void) WriteBlobString(image,buffer);
    for (y=0; y &lt; (long) image-&gt;rows; y++)
    {
      p=GetVirtualPixels(image,0,y,image-&gt;columns,1,&amp;image-&gt;exception);
      if (p == (const PixelPacket *) NULL)
        break;
      q=pixels;
      for (x=0; x &lt; (long) image-&gt;columns; x++)
      {
        *q++=ScaleQuantumToChar(p-&gt;red);
        *q++=ScaleQuantumToChar(p-&gt;green);
        *q++=ScaleQuantumToChar(p-&gt;blue);
        p++;
      }
      (void) WriteBlob(image,(size_t) (q-pixels),pixels);
      if ((image-&gt;previous == (Image *) NULL) &&
          (SetImageProgress(image,SaveImageTag,y,image-&gt;rows) == MagickFalse))
        break;
    }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,SaveImagesTag,scene,
      GetImageListLength(image));
    if (status == MagickFalse)
      break;
    scene++;
  } while (image_info-&gt;adjoin != MagickFalse);
  (void) CloseBlob(image);
  return(MagickTrue);
}
</pre>
</div>

<p>To invoke the custom coder from the command line, use these commands:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert logo: logo.mgk</span><span class='crtout'></span><span class="crtprompt"> $magick&gt; </span><span class='crtin'>display logo.mgk</span></p>
<p>We provide the <a href="ftp://ftp.imagemagick.org/pub/ImageMagick/kits/MagickCoderKit-1.0.0.tar.gz">Magick Coder Kit</a> to help you get started writing your own custom coder.</p>

</div>

<h2><a name="filters"></a>Custom Image Filters</h2>
<div class="doc-section">

<p>ImageMagick provides a convenient mechanism for adding your own custom image processing algorithms.  We call these image filters and they are invoked from the command line with the <a href="../www/command-line-options.html#process">-process</a> option or from the MagickCore API method <a href="../www/api/module.html#ExecuteModuleProcess">ExecuteModuleProcess()</a>.</p>

<p>Here is a listing of a sample <a href="../www/source/analyze.c">custom image filter</a>.  It computes a few statistics such as the pixel brightness and saturation mean and standard-deviation.</p>

<div class="viewport">
<pre class="code">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;assert.h&gt;
#include &lt;math.h&gt;
#include "magick/MagickCore.h"

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   a n a l y z e I m a g e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  analyzeImage() computes the brightness and saturation mean,  standard
%  deviation, kurtosis and skewness and stores these values as attributes 
%  of the image.
%
%  The format of the analyzeImage method is:
%
%      unsigned long analyzeImage(Image *images,const int argc,
%        char **argv,ExceptionInfo *exception)
%
%  A description of each parameter follows:
%
%    o image: the address of a structure of type Image.
%
%    o argc: Specifies a pointer to an integer describing the number of
%      elements in the argument vector.
%
%    o argv: Specifies a pointer to a text array containing the command line
%      arguments.
%
%    o exception: return any errors or warnings in this structure.
%
*/
ModuleExport unsigned long analyzeImage(Image **images,const int argc,
  const char **argv,ExceptionInfo *exception)
{
  char
    text[MaxTextExtent];

  double
    area,
    brightness,
    brightness_mean,
    brightness_standard_deviation,
    brightness_kurtosis,
    brightness_skewness,
    brightness_sum_x,
    brightness_sum_x2,
    brightness_sum_x3,
    brightness_sum_x4,
    hue,
    saturation,
    saturation_mean,
    saturation_standard_deviation,
    saturation_kurtosis,
    saturation_skewness,
    saturation_sum_x,
    saturation_sum_x2,
    saturation_sum_x3,
    saturation_sum_x4;

  Image
    *image;

  assert(images != (Image **) NULL);
  assert(*images != (Image *) NULL);
  assert((*images)-&gt;signature == MagickSignature);
  (void) argc;
  (void) argv;
  image=(*images);
  for ( ; image != (Image *) NULL; image=GetNextImageInList(image))
  {
    CacheView
      *image_view;

    long
      y;

    MagickBooleanType
      status;

    brightness_sum_x=0.0;
    brightness_sum_x2=0.0;
    brightness_sum_x3=0.0;
    brightness_sum_x4=0.0;
    brightness_mean=0.0;
    brightness_standard_deviation=0.0;
    brightness_kurtosis=0.0;
    brightness_skewness=0.0;
    saturation_sum_x=0.0;
    saturation_sum_x2=0.0;
    saturation_sum_x3=0.0;
    saturation_sum_x4=0.0;
    saturation_mean=0.0;
    saturation_standard_deviation=0.0;
    saturation_kurtosis=0.0;
    saturation_skewness=0.0;
    area=0.0;
    status=MagickTrue;
    image_view=AcquireCacheView(image);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
    #pragma omp parallel for schedule(dynamic,4) shared(status)
#endif
    for (y=0; y &lt; (long) image-&gt;rows; y++)
    {
      register const PixelPacket
        *p;

      register long
        x;

      if (status == MagickFalse)
        continue;
      p=GetCacheViewVirtualPixels(image_view,0,y,image-&gt;columns,1,exception);
      if (p == (const PixelPacket *) NULL)
        {
          status=MagickFalse;
          continue;
        }
      for (x=0; x &lt; (long) image-&gt;columns; x++)
      {
        ConvertRGBToHSB(p-&gt;red,p-&gt;green,p-&gt;blue,&amp;hue,&amp;saturation,&amp;brightness);
        brightness*=QuantumRange;
        brightness_sum_x+=brightness;
        brightness_sum_x2+=brightness*brightness;
        brightness_sum_x3+=brightness*brightness*brightness;
        brightness_sum_x4+=brightness*brightness*brightness*brightness;
        saturation*=QuantumRange;
        saturation_sum_x+=saturation;
        saturation_sum_x2+=saturation*saturation;
        saturation_sum_x3+=saturation*saturation*saturation;
        saturation_sum_x4+=saturation*saturation*saturation*saturation;
        area++;
        p++;
      }
    }
    image_view=DestroyCacheView(image_view);
    if (area &lt;= 0.0)
      break;
    brightness_mean=brightness_sum_x/area;
    (void) FormatMagickString(text,MaxTextExtent,"%g",brightness_mean);
    (void) SetImageProperty(image,"filter:brightness:mean",text);
    brightness_standard_deviation=sqrt(brightness_sum_x2/area-(brightness_sum_x/
      area*brightness_sum_x/area));
    (void) FormatMagickString(text,MaxTextExtent,"%g",
      brightness_standard_deviation);
    (void) SetImageProperty(image,"filter:brightness:standard-deviation",text);
    if (brightness_standard_deviation != 0)
      brightness_kurtosis=(brightness_sum_x4/area-4.0*brightness_mean*
        brightness_sum_x3/area+6.0*brightness_mean*brightness_mean*
        brightness_sum_x2/area-3.0*brightness_mean*brightness_mean*
        brightness_mean*brightness_mean)/(brightness_standard_deviation*
        brightness_standard_deviation*brightness_standard_deviation*
        brightness_standard_deviation)-3.0;
    (void) FormatMagickString(text,MaxTextExtent,"%g",brightness_kurtosis);
    (void) SetImageProperty(image,"filter:brightness:kurtosis",text);
    if (brightness_standard_deviation != 0)
      brightness_skewness=(brightness_sum_x3/area-3.0*brightness_mean*
        brightness_sum_x2/area+2.0*brightness_mean*brightness_mean*
        brightness_mean)/(brightness_standard_deviation*
        brightness_standard_deviation*brightness_standard_deviation);
    (void) FormatMagickString(text,MaxTextExtent,"%g",brightness_skewness);
    (void) SetImageProperty(image,"filter:brightness:skewness",text);
    saturation_mean=saturation_sum_x/area;
    (void) FormatMagickString(text,MaxTextExtent,"%g",saturation_mean);
    (void) SetImageProperty(image,"filter:saturation:mean",text);
    saturation_standard_deviation=sqrt(saturation_sum_x2/area-(saturation_sum_x/
      area*saturation_sum_x/area));
    (void) FormatMagickString(text,MaxTextExtent,"%g",
      saturation_standard_deviation);
    (void) SetImageProperty(image,"filter:saturation:standard-deviation",text);
    if (saturation_standard_deviation != 0)
      saturation_kurtosis=(saturation_sum_x4/area-4.0*saturation_mean*
        saturation_sum_x3/area+6.0*saturation_mean*saturation_mean*
        saturation_sum_x2/area-3.0*saturation_mean*saturation_mean*
        saturation_mean*saturation_mean)/(saturation_standard_deviation*
        saturation_standard_deviation*saturation_standard_deviation*
        saturation_standard_deviation)-3.0;
    (void) FormatMagickString(text,MaxTextExtent,"%g",saturation_kurtosis);
    (void) SetImageProperty(image,"filter:saturation:kurtosis",text);
    if (saturation_standard_deviation != 0)
      saturation_skewness=(saturation_sum_x3/area-3.0*saturation_mean*
        saturation_sum_x2/area+2.0*saturation_mean*saturation_mean*
        saturation_mean)/(saturation_standard_deviation*
        saturation_standard_deviation*saturation_standard_deviation);
    (void) FormatMagickString(text,MaxTextExtent,"%g",saturation_skewness);
    (void) SetImageProperty(image,"filter:saturation:skewness",text);
  }
  return(MagickImageFilterSignature);
}
</pre>
</div>

<p>To invoke the custom filter from the command line, use this command:</p>

<p class='crt'><span class="crtprompt"> $magick&gt; </span><span class='crtin'>convert logo: -process analyze -verbose info:</span><span class='crtout'>Image: logo: <br/>
    Format: LOGO (ImageMagick Logo)  <br/>
    Class: PseudoClass  <br/>
    Geometry: 640x480  <br/>
    ...  <br/>
    filter:brightness:kurtosis: 8.98864 <br/>
    filter:brightness:mean: 238.096 <br/>
    filter:brightness:skewness: -3.04519 <br/>
    filter:brightness:standard-deviation: 46.3286 <br/>
    filter:saturation:kurtosis: 5.9137 <br/>
    filter:saturation:mean: 23.4635 <br/>
    filter:saturation:skewness: 2.71874 <br/>
    filter:saturation:standard-deviation: 64.7734</span></p>

<p>We provide the <a href="ftp://ftp.imagemagick.org/pub/ImageMagick/kits/MagickFilterKit-1.0.0.tar.gz">Magick Filter Kit</a> to help you get started writing your own custom image filter.</p>

</div>

</div>

<div id="linkbar">
 <!--    <span id="linkbar-west">&nbsp;</span>  -->
    <span id="linkbar-center">
      <a href="http://www.imagemagick.org/discourse-server/">Discourse Server</a> &bull;
    <a href="http://www.imagemagick.org/MagickStudio/scripts/MagickStudio.cgi">Studio</a>
    </span>
    <span id="linkbar-east">&nbsp;</span>
  </div>
  <div class="footer">
    <span id="footer-west">&copy; 1999-2010 ImageMagick Studio LLC</span>
    <span id="footer-east"> <a href="http://www.imagemagick.org/script/contact.php">Contact the Wizards</a></span>
  </div>
  <div style="clear: both; margin: 0; width: 100%; "></div>
</body>
</html>

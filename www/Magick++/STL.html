<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Magick++ API: STL Templates</title>
<link rel="stylesheet" href="magick.css" type="text/css" />
</head>
<body>
<div class="doc-section">
<h1> Magick++ STL Support</h1>
Magick++ provides a set of <a href="http://www.sgi.com/tech/stl/">Standard
Template Libary</a> (<a href="http://www.sgi.com/tech/stl/">STL</a> )
algorithms for operating across ranges of image frames in a container.
It also provides a set of STL unary function objects to apply an
operation on image frames in a container via an algorithm which uses
unary function objects. A good example of a standard algorithm which is
useful for processing containers of image frames is the STL <i><a
 href="http://www.sgi.com/tech/stl/for_each.html"> for_each</a> </i>
algorithm which invokes a unary function object on a range of container
elements.
<p>Magick++ uses a limited set of template argument types. The current
template argument types are: </p>
<a href="http://www.sgi.com/tech/stl/Container.html">Container</a>
<blockquote>A container having the properties of a <a
 href="http://www.sgi.com/tech/stl/BackInsertionSequence.html"> Back
Insertion Sequence</a> . Sequences support forward iterators and Back
Insertion Sequences support the additional abilty to append an element
via push_back(). Common compatable container types are the STL &lt;<a
 href="http://www.sgi.com/tech/stl/Vector.html"> vector</a> &gt; and &lt;<a
 href="http://www.sgi.com/tech/stl/List.html">list</a> &gt; template
containers. This template argument is usually used to represent an
output container in which one or more image frames may be appended.
Containers like STL &lt;<a href="http://www.sgi.com/tech/stl/Vector.html">vector</a>
&gt; which have a given default <i>capacity</i> may need to have their <i>
capacity</i> adjusted via r<i>eserve() </i>to a larger <i>capacity</i>
in order to support the expected final <i>size</i> . Since Magick++
images are very small, it is likely that the default capacity of STL &lt;<a
 href="http://www.sgi.com/tech/stl/Vector.html"> vector</a> &gt; is
sufficient for most situations.</blockquote>
  <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
  <blockquote>An input iterator used to express a position in a
container. These template arguments are typically used to represent a
range of elements  with f<i>irst_</i> representing the first element to
be processed and <i> last_</i> representing the element to stop at. When
processing the entire contents of a container, it is handy to know that
STL containers usually provide the begin() and end() methods to return
input interators which correspond  with the first and last elements,
respectively.</blockquote>
<p>The following is an example of how frames from a GIF animation <font
 color="#000000"> "test_image_anim.gif" may be appended horizontally
with the resulting image written to the file <kbd>appended_image.miff</kbd>:</font></p>
<pre class="code">
#include &lt;list> 
#include &lt;Magick++.h> 
using namespace std; 
using namespace Magick;

int main(int /*argc*/,char **/*argv*/) 
{ 
   list&lt;Image> imageList; 
   readImages( &amp;imageList, "test_image_anim.gif" );

   Image appended; 
   appendImages( &amp;appended, imageList.begin(), imageList.end() ); 
   appended.write( "appended_image.miff" ); 
   return 0; 
}
</pre>
<p>The available Magick++ specific STL algorithms for operating on
sequences of image frames are shown in the following table: <br />
&#160;
<ul><table border="1" width="100%">
  <caption><b>Magick++ STL Algorithms For Image Sequences</b></caption> <tbody>
    <tr>
      <td>
      <center><b>Algorithm</b></center>
      </td>
      <td>
      <center><b>Signature</b></center>
      </td>
      <td>
      <center><b>Description</b></center>
      </td>
    </tr>
    <tr>
      <td>
      <center><a name="animateImages"></a> <font size="-1">animateImages</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_</font></td>
      <td><font size="-1">Animate a sequence of image frames. Image
frames are  displayed in succession, creating an animated effect. The
animation options  are taken from the first image frame. This feature is
only supported under  X11 at the moment.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="appendImages"></a> <font size="-1">appendImages</font></center>
      </td>
      <td><font size="-1"><a href="Image.html">Image</a>
*appendedImage_, <a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_, bool stack_ = false</font></td>
      <td><font size="-1">Append a sequence of image frames, writing
the result  to <i>appendedImage_.</i> All the input image frames must
have the same width or height. Image frames of the same width are
stacked top-to-bottom. Image frames of the same height are stacked
left-to-right. If the <i>stack_</i> parameter is false, rectangular
image frames are stacked left-to-right otherwise top-to-bottom.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="averageImages"></a> <font size="-1">averageImages</font></center>
      </td>
      <td><font size="-1"><a href="Image.html">Image</a>
*averagedImage_, <a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_</font></td>
      <td><font size="-1">Average a sequence of image frames, writing
the result  to <i>averagedImage_</i>. All the input image frames must
be the same size  in pixels.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="coalesceImages"></a> <font size="-1">coalesceImages</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/Container.html"> Container</a>
*coalescedImages_, <a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_</font><br />
      </td>
      <td><font size="-1">Create a coalesced image sequence obtained by
"playing" the image sequence (observing page offsets and disposal
methods) to create a new image sequence in which all frames are full
size and completely rendered. Note that if the original image sequence
relied on page offsets and disposal methods that the resulting sequence
will be larger (perhaps much larger) then the original. This is useful
for GIF animation sequences that have page offsets and disposal methods.
The resuting image sequence is returned via <i>coalescedImages_.</i></font></td>
    </tr>
    <tr>
      <td>
      <center><a name="deconstructImages"></a> <font size="-1">deconstructImages</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/Container.html"> Container</a>
*deconstructedImages_, <a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_</font></td>
      <td><font size="-1">Break down an image sequence into constituent
parts.&#160; This is useful for creating GIF or MNG animation sequences.
The input sequence  is specified by <i>first_</i> and <i>last_</i>, and
the deconstructed images  are returned via <i>deconstructedImages_</i>.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="displayImages"></a> <font size="-1">displayImages</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_</font></td>
      <td><font size="-1">Display a sequence of image frames. Through
use of a pop-up menu, image frames may be selected in succession. This
feature is  fully supported under X11 but may have only limited support
in other environments.</font> <br />
      <font size="-1"><b><font color="#ff0000">Caution: </font></b> if
an image format is is not compatable with the display visual (e.g. JPEG
on a colormapped display) then the original image will be altered. Use a
copy of the original if this is a problem.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="flattenImages"></a> <font size="-1">flattenImages</font></center>
      </td>
      <td><font size="-1"><a href="Image.html">Image</a>
*flattendImage_, <a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_</font></td>
      <td><font size="-1">Merge a sequence of image frames which
represent image  layers into a single composited representation. The <i>flattendImage_</i>
parameter points to an existing Image to update with the flattened
image. This function is useful for combining Photoshop layers into a
single image.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="forwardFourierTransformImage"></a> <font size="-1">forwardFourierTransformImage</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/Container.html"> Container</a>
*fourierImages_, const Image &amp;image_ </font></td>
      <td><font size="-1"> Implements the discrete Fourier transform (DFT) of the image as a magnitude / phase image pair via <i>fourierImages_</i>.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="forwardFourierTransformImage"></a> <font size="-1">forwardFourierTransformImage</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/Container.html"> Container</a>
*fourierImages_, const Image &amp;image_, const bool magnitude_ </font></td>
      <td><font size="-1"> Implements the discrete Fourier transform (DFT) of the image either as a magnitude / phase or real / imaginary image pair via <i>fourierImages_</i>.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="mapImages"></a> <font size="-1">mapImages</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_, const <a href="Image.html">Image</a> &amp; mapImage_, bool
dither_,&#160; bool measureError_ = false</font></td>
      <td><font size="-1">Replace the colors of a sequence of images
with the closest color from a reference image. Set <i>dither_</i> to <i>true</i>
to enable dithering.&#160; Set <i>measureError_</i> to <i>true</i> in
order to evaluate quantization error.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="montageImages"></a> <font size="-1">montageImages</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/Container.html"> Container</a>
*montageImages_, <a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_, const <a href="Montage.html">Montage</a> &amp;montageOpts_</font></td>
      <td><font size="-1">Create a composite image by combining several
separate image frames. Multiple frames may be generated in the output
container <i> montageImages_ </i>depending on the tile setting and the
number of image frames montaged. Montage options are provided via the
parameter <i>montageOpts_</i> . Options set in the first image frame (<a
 href="Image.html#backgroundColor"> backgroundColor,</a> <a
 href="Image.html#borderColor">borderColor</a> , <a
 href="Image.html#matteColor">matteColor</a> , <a
 href="Image.html#penColor">penColor,</a> <a href="Image.html#font">font,</a>
and <a href="Image.html#fontPointsize">fontPointsize</a> ) are also used
as options by <i>montageImages().</i></font></td>
    </tr>
    <tr>
      <td>
      <center><a name="morphImages"></a> <font size="-1">morphImages</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/Container.html"> Container</a>
*morphedImages_, <a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_, size_t frames_</font></td>
      <td><font size="-1">Morph a seqence of image frames. This
algorithm&#160; expands the number of image frames (output to the
container <i>morphedImages_)</i> by adding the number of intervening
frames specified by <i>frames_</i> such that the original frames morph
(blend) into each other when played as an animation.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="mosaicImages"></a> <font size="-1">mosaicImages</font></center>
      </td>
      <td><font size="-1"><a href="Image.html">Image</a> *mosaicImage_, <a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_</font></td>
      <td><font size="-1">Inlay a number of images to form a single
coherent picture. The <i>mosicImage_</i> argument is updated with a
mosaic constructed from the image sequence represented by <i>first_</i>
through <i>last_</i> .</font></td>
    </tr>
    <tr>
      <td><center><a name="quantizeImages"></a> <font size="-1">quantizeImages</font></center></td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_, bool measureError_ = false</font></td>
      <td><font size="-1">Quantize colors in images using current
quantization settings. Set <i>measureError_</i> to <i>true</i> in order
to measure quantization  error.</font></td>
    </tr>
    <tr>
      <td rowspan="2">
      <center><a name="readImages"></a> <font size="-1">readImages</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/Container.html"> Container</a>
*sequence_, const std::string &amp;imageSpec_</font></td>
      <td><font size="-1">Read a sequence of image frames into existing
container (appending to container <i>sequence_</i>) with image names
specified in the UTF-8 string <i>imageSpec_</i>.</font></td>
    </tr>
    <tr>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/Container.html"> Container</a>
*sequence_, const <a href="Blob.html">Blob</a> &amp;blob_</font></td>
      <td><font size="-1">Read a sequence of image frames into existing
container (appending to container sequence_) from <a href="Blob.html">Blob</a>
blob_.</font></td>
    </tr>
    <tr>
      <td rowspan="2">
      <center><a name="writeImages"></a> <font size="-1">writeImages</font></center>
      </td>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_, const std::string &amp;imageSpec_, bool adjoin_ = true</font></td>
      <td><font size="-1">Write images in container to file specified
by string <i>imageSpec_</i>. Set <i>adjoin_ </i>to false to write a
set of image frames via a wildcard <i>imageSpec_ </i>(e.g.
image%02d.miff).</font> <br />
The wildcard must be one of <tt>%0Nd, %0No, or %0Nx</tt>. <br />
      <font size="-1"><b><font color="#ff0000">Caution: </font></b> if
an image format is selected which is capable of supporting fewer colors
than the original image or quantization has been requested, the original
image will be quantized to fewer colors. Use a copy of the original if
this is a problem.</font></td>
    </tr>
    <tr>
      <td><font size="-1"><a
 href="http://www.sgi.com/tech/stl/InputIterator.html"> InputIterator</a>
first_, <a href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
last_, <a href="Blob.html">Blob</a> *blob_, bool adjoin_ = true</font></td>
      <td><font size="-1">Write images in container to in-memory BLOB
specified by <a href="Blob.html">Blob</a> blob_. Set adjoin_ to false to
write a set of image frames via a wildcard imageSpec_ (e.g.
image%02d.miff).</font> <br />
      <font size="-1"><b><font color="#ff0000">Caution:</font></b> if an
image format is selected which is capable of supporting fewer colors
than the original image or quantization has been requested, the original
image will be quantized to fewer colors. Use a copy of the original if
this is a problem.</font></td>
    </tr>
  </tbody>
</table></ul>
<p>In addition, we support these yet to be documented methods: <code>combineImages()</code>, <code>evaluateImages()</code>, <code>mergeImageLayers()</code>, <code>optimizeImageLayers()</code>, <code>optimizePlusImageLayers()</code>, and <code>separateImages()</code>.</p>
<br />
&#160; </p>
<center>
<h3> Magick++ Unary Function Objects</h3>
</center>
Magick++ unary function objects inherit from the STL unary_function
template class . The STL unary_function template class is of the form
<pre class="text"><tt><font color="#000099">unary_function&lt;Arg, Result&gt;</font></tt></pre>
and expects that derived classes implement a method of the form:
<pre class="text"><tt><font color="#000099">Result operator()( Arg argument_);</font></tt></pre>
which is invoked by algorithms using the function object. In the case
of unary function objects defined by Magick++, the invoked function
looks like:
<pre class="text"><tt><font color="#000099">void operator()( Image &amp;image_);</font></tt></pre>
with a typical implementation looking similar to:
<pre class="text"><tt><font color="#000099">void operator()( Image &amp;image_ )</font></tt> <br />
  <tt><font color="#000099">&#160; {</font></tt> <br />
  <tt><font color="#000099">&#160;&#160;&#160; image_.contrast(
_sharpen );</font></tt> <br />
  <tt><font color="#000099">&#160; }</font></tt></pre>
where <i>contrast</i> is an Image method and <i>_sharpen </i>is an
argument stored within the function object by its contructor. Since
constructors may be polymorphic, a given function object may have
several constructors and selects the appropriate Image method based on
the arguments supplied.
<p>In essence, unary function objects (as provided by Magick++) simply
provide the means to construct an object which caches arguments for
later use by an algorithm designed for use with unary function objects.
There is a unary function object corresponding each algorithm provided
by the <a href="Image.html"> Image</a> class and there is a contructor
available compatable with each synonymous  method in the Image class. </p>
<p>The unary function objects that Magick++ provides to support
manipulating images are shown in the following table: <br />
&#160;
<ul><table border="1">
  <caption><b>Magick++ Unary Function Objects For Image Manipulation</b></caption> <tbody>
    <tr align="center">
      <td><b>Function Object</b></td>
      <td><b>Constructor Signatures(s)</b></td>
      <td><b>Description</b></td>
    </tr>
    <tr>
      <td valign="middle">
      <div align="center"><a name="adaptiveThresholdImage"></a> <font
 size="-1">adaptiveThresholdImage</font><br />
      </div>
      </td>
      <td valign="middle"><font size="-1">size_t width, size_t
height, unsigned offset = 0</font><br />
      </td>
      <td valign="top"><font size="-1">Apply adaptive thresholding to
the image. Adaptive thresholding is useful if the ideal threshold level
is not known in advance, or if the illumination gradient is not constant
across the image. Adaptive thresholding works by evaulating the mean
(average) of a pixel region (size specified by <i>width</i> and <i>height</i>)
and using the mean as the thresholding value. In order to remove
residual noise from the background, the threshold may be adjusted by
subtracting a constant <i>offset</i> (default zero) from the mean to
compute the threshold.</font><br />
      </td>
    </tr>
    <tr>
      <td>
      <center><a name="addNoiseImage"></a> <font size="-1">addNoiseImage</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#NoiseType">NoiseType</a>
noiseType_</font></td>
      <td><font size="-1">Add noise to image with specified noise type.</font></td>
    </tr>
    <tr>
      <td style="vertical-align: middle;"><small><a
 name="affineTransformImage"></a>affineTransformImage<br />
      </small></td>
      <td style="vertical-align: middle;"><small>const DrawableAffine
&amp;affine_<br />
      </small></td>
      <td style="vertical-align: middle;"><small>Transform image by
specified affine (or free transform) matrix.<br />
      </small></td>
    </tr>
    <tr>
      <td rowspan="4">
      <center><a name="annotateImage"></a> <font size="-1">annotateImage</font></center>
      </td>
      <td><font size="-1">const std::string &amp;text_, const <a
 href="Geometry.html"> Geometry</a> &amp;location_</font></td>
      <td><font size="-1">Annotate with text using specified text,
bounding area,  placement gravity, and rotation. If <i>boundingArea_</i>
is invalid, then  bounding area is entire image.</font></td>
    </tr>
    <tr>
      <td><font size="-1">std::string text_, const <a
 href="Geometry.html">Geometry</a> &amp;boundingArea_, <a
 href="Enumerations.html#GravityType">GravityType</a> gravity_</font></td>
      <td><font size="-1">Annotate using specified text, bounding area,
and placement  gravity. If <i>boundingArea_</i> is invalid, then
bounding area is entire  image.</font></td>
    </tr>
    <tr>
      <td><font size="-1">const std::string &amp;text_, const <a
 href="Geometry.html"> Geometry</a> &amp;boundingArea_, <a
 href="Enumerations.html#GravityType">GravityType</a> gravity_, double
degrees_,&#160;</font></td>
      <td><font size="-1">Annotate with text using specified text,
bounding area,  placement gravity, and rotation. If <i>boundingArea_</i>
is invalid, then  bounding area is entire image.</font></td>
    </tr>
    <tr>
      <td><font size="-1">const std::string &amp;text_, <a
 href="Enumerations.html#GravityType"> GravityType</a> gravity_</font></td>
      <td><font size="-1">Annotate with text (bounding area is entire
image) and placement gravity.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="blurImage"></a> <font size="-1">blurImage</font></center>
      </td>
      <td><font size="-1">const double radius_ = 1, const double sigma_
= 0.5</font></td>
      <td><font size="-1">Blur image. The radius_ parameter specifies
the radius  of the Gaussian, in pixels, not counting the center
pixel.&#160; The sigma_  parameter specifies the standard deviation of
the Laplacian, in pixels.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="borderImage"></a> <font size="-1">borderImage</font></center>
      </td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;geometry_ = "6x6+0+0"</font></td>
      <td><font size="-1">Border image (add border to image).&#160; The
color of the border is specified by the <i>borderColor</i> attribute.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="charcoalImage"></a> <font size="-1">charcoalImage</font></center>
      </td>
      <td><font size="-1">const double radius_ = 1, const double sigma_
= 0.5</font></td>
      <td><font size="-1">Charcoal effect image (looks like charcoal
sketch). The radius_ parameter specifies the radius of the Gaussian, in
pixels, not  counting the center pixel.&#160; The sigma_ parameter
specifies the standard  deviation of the Laplacian, in pixels.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="chopImage"></a> <font size="-1">chopImage</font></center>
      </td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;geometry_</font></td>
      <td><font size="-1">Chop image (remove vertical or horizontal
subregion of image)</font></td>
    </tr>
    <tr>
      <td rowspan="2">
      <center><a name="colorizeImage"></a> <font size="-1">colorizeImage</font></center>
      </td>
      <td><font size="-1">const size_t opacityRed_, const
size_t opacityGreen_, const size_t opacityBlue_, const Color
&amp;penColor_</font></td>
      <td><font size="-1">Colorize image with pen color, using
specified percent  opacity for red, green, and blue quantums.</font></td>
    </tr>
    <tr>
      <td><font size="-1">const size_t opacity_, const <a
 href="Color.html"> Color</a> &amp;penColor_</font></td>
      <td><font size="-1">Colorize image with pen color, using
specified percent  opacity.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="commentImage"></a> <font size="-1">commentImage</font></center>
      </td>
      <td><font size="-1">const std::string &amp;comment_</font></td>
      <td><font size="-1">Comment image (add comment string to
image).&#160; By default, each image is commented with its file name.
Use&#160; this&#160;  method to&#160; assign a specific comment to the
image.&#160; Optionally you can include the image filename, type, width,
height, or other&#160; image&#160; attributes by embedding <a
 href="FormatCharacters.html">special format characters.</a> </font></td>
    </tr>
    <tr>
      <td rowspan="2">
      <center><a name="compositeImage"></a> <font size="-1">compositeImage</font></center>
      </td>
      <td><font size="-1">const <a href="Image.html">Image</a>
&amp;compositeImage_, ssize_t xOffset_, ssize_t yOffset_, <a
 href="Enumerations.html#CompositeOperator"> CompositeOperator</a>
compose_ = <i>InCompositeOp</i></font></td>
      <td rowspan="2"><font size="-1">Compose an image onto another at
specified offset and using specified algorithm</font></td>
    </tr>
    <tr>
      <td><font size="-1">const <a href="Image.html">Image</a>
&amp;compositeImage_, const Geometry &amp;offset_, <a
 href="Enumerations.html#CompositeOperator"> CompositeOperator</a>
compose_ = <i>InCompositeOp</i></font></td>
    </tr>
    <tr>
      <td>
      <center><a name="condenseImage"></a> <font size="-1">condenseImage</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td><font size="-1">Condense image (Re-run-length encode image in
memory).</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="contrastImage"></a> <font size="-1">contrastImage</font></center>
      </td>
      <td><font size="-1">size_t sharpen_</font></td>
      <td><font size="-1">Contrast image (enhance intensity differences
in image)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="cropImage"></a> <font size="-1">cropImage</font></center>
      </td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;geometry_</font></td>
      <td><font size="-1">Crop image (subregion of original image)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="cycleColormapImage"></a> <font size="-1">cycleColormap-</font> <br />
      <font size="-1">Image</font></center>
      </td>
      <td><font size="-1">int amount_</font></td>
      <td><font size="-1">Cycle image colormap</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="despeckleImage"></a> <font size="-1">despeckleImage</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td><font size="-1">Despeckle image (reduce speckle noise)</font></td>
    </tr>
    <tr>
      <td rowspan="2">
      <center><a name="drawImage"></a> <font size="-1">drawImage</font></center>
      </td>
      <td><font size="-1">const <a href="Drawable.html">Drawable</a>
&amp;drawable_</font></td>
      <td><font size="-1">Draw shape or text on image.</font></td>
    </tr>
    <tr>
      <td><font size="-1">const std::list&lt;<a href="Drawable.html">Drawable</a>
&gt; &amp;drawable_</font></td>
      <td><font size="-1">Draw shapes or text on image using a set of
Drawable objects contained in an STL list. Use of this method improves
drawing performance  and allows batching draw objects together in a list
for repeated use.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="edgeImage"></a> <font size="-1">edgeImage</font></center>
      </td>
      <td><font size="-1">size_t radius_ = 0.0</font></td>
      <td><font size="-1">Edge image (hilight edges in image).&#160;
The radius  is the radius of the pixel neighborhood.. Specify a radius
of zero for automatic radius selection.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="embossImage"></a> <font size="-1">embossImage</font></center>
      </td>
      <td><font size="-1">const double radius_ = 1, const double sigma_
= 0.5</font></td>
      <td><font size="-1">Emboss image (hilight edges with 3D effect).
The radius_  parameter specifies the radius of the Gaussian, in pixels,
not counting the center pixel.&#160; The sigma_ parameter specifies the
standard deviation  of the Laplacian, in pixels.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="enhanceImage"></a> <font size="-1">enhanceImage</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td><font size="-1">Enhance image (minimize noise)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="equalizeImage"></a> <font size="-1">equalizeImage</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td><font size="-1">Equalize image (histogram equalization)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="flipImage"></a> <font size="-1">flipImage</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td><font size="-1">Flip image (reflect each scanline in the
vertical direction)</font></td>
    </tr>
    <tr>
      <td rowspan="4">
      <center><a name="floodFillColorImage"></a> <font size="-1">floodFill-</font> <br />
      <font size="-1">ColorImage</font></center>
      </td>
      <td><font size="-1">ssize_t x_, ssize_t y_, const <a
 href="Color.html"> Color</a> &amp;fillColor_</font></td>
      <td rowspan="2"><font size="-1">Flood-fill color across pixels
that match  the color of the target pixel and are neighbors of the
target pixel. Uses  current fuzz setting when determining color match.</font></td>
    </tr>
    <tr>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;point_, const <a href="Color.html">Color</a> &amp;fillColor_</font></td>
    </tr>
    <tr>
      <td><font size="-1">ssize_t x_, ssize_t y_, const <a
 href="Color.html"> Color</a> &amp;fillColor_, const <a href="Color.html">Color</a>
&amp;borderColor_</font></td>
      <td rowspan="2"><font size="-1">Flood-fill color across pixels
starting at target-pixel and stopping at pixels matching specified
border color. Uses  current fuzz setting when determining color match.</font></td>
    </tr>
    <tr>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;point_, const <a href="Color.html">Color</a> &amp;fillColor_, const <a
 href="Color.html">Color</a> &amp;borderColor_</font></td>
    </tr>
    <tr>
      <td rowspan="4">
      <center><a name="floodFillTextureImage"></a> <font size="-1">floodFill-</font> <br />
      <font size="-1">TextureImage</font></center>
      </td>
      <td><font size="-1">ssize_t x_, ssize_t y_,&#160; const <a
 href="Image.html"> Image</a> &amp;texture_</font></td>
      <td rowspan="2"><font size="-1">Flood-fill texture across pixels
that match  the color of the target pixel and are neighbors of the
target pixel. Uses  current fuzz setting when determining color match.</font></td>
    </tr>
    <tr>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;point_, const Image &amp;texture_</font></td>
    </tr>
    <tr>
      <td><font size="-1">ssize_t x_, ssize_t y_, const Image
&amp;texture_, const <a href="Color.html">Color</a> &amp;borderColor_</font></td>
      <td rowspan="2"><font size="-1">Flood-fill texture across pixels
starting at target-pixel and stopping at pixels matching specified
border color. Uses current fuzz setting when determining color match.</font></td>
    </tr>
    <tr>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;point_, const Image &amp;texture_, const <a href="Color.html">Color</a>
&amp;borderColor_</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="flopImage"></a> <font size="-1">flopImage</font></center>
      </td>
      <td><font size="-1">void&#160;</font></td>
      <td><font size="-1">Flop image (reflect each scanline in the
horizontal direction)</font></td>
    </tr>
    <tr>
      <td rowspan="2">
      <center><a name="frameImage"></a> <font size="-1">frameImage</font></center>
      </td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;geometry_ = "25x25+6+6"</font></td>
      <td rowspan="2"><font size="-1">Add decorative frame around image</font></td>
    </tr>
    <tr>
      <td><font size="-1">size_t width_, size_t height_,
ssize_t x_, ssize_t  y_, ssize_t innerBevel_ = 0, ssize_t outerBevel_ = 0</font></td>
    </tr>
    <tr>
      <td rowspan="2">
      <center><a name="gammaImage"></a> <font size="-1">gammaImage</font></center>
      </td>
      <td><font size="-1">double gamma_</font></td>
      <td><font size="-1">Gamma correct image (uniform red, green, and
blue correction).</font></td>
    </tr>
    <tr>
      <td><font size="-1">double gammaRed_, double gammaGreen_, double
gammaBlue_</font></td>
      <td><font size="-1">Gamma correct red, green, and blue channels
of image.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="gaussianBlur"></a> <font size="-1">gaussianBlurImage</font></center>
      </td>
      <td><font size="-1">double width_, double sigma_</font></td>
      <td><font size="-1">Gaussian blur image. The number of neighbor
pixels to be included in the convolution mask is specified by
'width_'.&#160; For  example, a width of one gives a (standard) 3x3
convolution mask. The standard  deviation of the gaussian bell curve is
specified by 'sigma_'.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="implodeImage"></a> <font size="-1">implodeImage</font></center>
      </td>
      <td><font size="-1">double factor_</font></td>
      <td><font size="-1">Implode image (special effect)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="inverseFourierTransformImage"></a> <font size="-1">inverseFourierTransformImage</font></center>
      </td>
      <td><font size="-1">const <a href="Image.html">Image</a>
&amp;phaseImage_, const bool magnitude_</font></td>
      <td><font size="-1">implements the inverse discrete Fourier transform (DFT) of the image either as a magnitude / phase or real / imaginary image pair.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="labelImage"></a> <font size="-1">labelImage</font></center>
      </td>
      <td><font size="-1">const string &amp;label_</font></td>
      <td><font size="-1">Assign a label to an image. Use this option
to&#160; assign&#160; a&#160; specific label to the image. Optionally
you can include  the image filename, type, width, height, or scene
number in the label by embedding&#160; <a href="FormatCharacters.html">special
format characters.</a> If the first character of string is @, the image
label is read from a file titled by the remaining characters in the
string. When converting to Postscript,  use this&#160; option to specify
a header string to print above the image.</font></td>
    </tr>
    <tr>
      <td style="text-align: center; vertical-align: middle;"><small><a
 name="levelImage"></a>levelImage<br />
      </small></td>
      <td style="vertical-align: top;"><small>const double black_point,
const double white_point, const double mid_point=1.0<br />
      </small></td>
      <td style="vertical-align: top;"><small>Level image. Adjust the
levels of the image by scaling the colors falling between specified
white and black points to the full available quantum range. The
parameters provided represent the black, mid (gamma), and white
points.&#160; The black point specifies the darkest color in the image.
Colors darker than the black point are set to zero. Mid point (gamma)
specifies a gamma correction to apply to the image. White point
specifies the lightest color in the image.&#160; Colors brighter than
the white point are set to the maximum quantum value. The black and
white point have the valid range 0 to QuantumRange while mid (gamma) has a
useful range of 0 to ten.</small></td>
    </tr>
    <tr>
      <td style="text-align: center; vertical-align: middle;"><small><a
 name="levelChannelImage"></a>levelChannelImage<br />
      </small></td>
      <td style="vertical-align: top;"><small>const Magick::ChannelType
channel, const double black_point, const double white_point, const
double mid_point=1.0<br />
      </small></td>
      <td style="vertical-align: top;"><small>Level image channel.
Adjust the levels of the image channel by scaling the values falling
between specified white and black points to the full available quantum
range. The parameters provided represent the black, mid (gamma), and
white points. The black point specifies the darkest color in the image.
Colors darker than the black point are set to zero. Mid point (gamma)
specifies a gamma correction to apply to the image. White point
specifies the lightest color in the image. Colors brighter than the
white point are set to the maximum quantum value. The black and white
point have the valid range 0 to QuantumRange while mid (gamma) has a useful
range of 0 to ten.</small></td>
    </tr>
    <tr>
      <td>
      <center><a name="layerImage"></a> <font size="-1">layerImage</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#ChannelType">ChannelType</a>
layer_</font></td>
      <td><font size="-1">Extract layer from image. Use this option to
extract a particular layer from&#160; the image.&#160; <i>MatteLayer</i>,&#160;
for&#160; example, is useful for extracting the opacity values from an
image.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="magnifyImage"></a> <font size="-1">magnifyImage</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td><font size="-1">Magnify image by integral size</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="mapImage"></a> <font size="-1">mapImage</font></center>
      </td>
      <td><font size="-1">const <a href="Image.html">Image</a>
&amp;mapImage_ , bool dither_ = false</font></td>
      <td><font size="-1">Remap image colors with closest color from
reference image. Set dither_ to <i>true</i> in to apply Floyd/Steinberg
error diffusion  to the image. By default, color reduction chooses an
optimal&#160; set&#160;  of colors that best represent the original
image. Alternatively, you can&#160; choose&#160; a&#160;
particular&#160; set&#160; of colors&#160; from&#160;  an image file
with this option.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="matteFloodfillImage"></a> <font size="-1">matteFloodfill-</font> <br />
      <font size="-1">Image</font></center>
      </td>
      <td><font size="-1">const <a href="Color.html">Color</a>
&amp;target_, unsigned int matte_, ssize_t x_, ssize_t y_, <a
 href="Enumerations.html#PaintMethod"> PaintMethod</a> method_</font></td>
      <td><font size="-1">Floodfill designated area with a matte value</font></td>
    </tr>
    <tr>
      <td><a name="medianFilterImage"></a> <font size="-1">medianFilterImage</font></td>
      <td><font size="-1">const double radius_ = 0.0</font></td>
      <td><font size="-1">Filter image by replacing each pixel
component with the median color in a circular neighborhood</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="minifyImage"></a> <font size="-1">minifyImage</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td><font size="-1">Reduce image by integral size</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="modulateImage"></a> <font size="-1">modulateImage</font></center>
      </td>
      <td><font size="-1">double brightness_, double saturation_,
double hue_</font></td>
      <td><font size="-1">Modulate percent hue, saturation, and
brightness of an image.&#160;</font><font size="-1">Modulation of
saturation and brightness is as a ratio of the current value (1.0 for no
change). Modulation of hue is an absolute rotation of -180 degrees to
+180 degrees from the current position corresponding to an argument
range of 0 to 2.0 (1.0 for no change).</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="negateImage"></a> <font size="-1">negateImage</font></center>
      </td>
      <td><font size="-1">bool grayscale_ = false</font></td>
      <td><font size="-1">Negate colors in image.&#160; Replace every
pixel with  its complementary color (white becomes black, yellow becomes
blue, etc.).&#160;  Set grayscale to only negate grayscale values in
image.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="normalizeImage"></a> <font size="-1">normalizeImage</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td><font size="-1">Normalize image (increase contrast by
normalizing the  pixel values to span the full range of color values).</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="oilPaintImage"></a> <font size="-1">oilPaintImage</font></center>
      </td>
      <td><font size="-1">size_t radius_ = 3</font></td>
      <td><font size="-1">Oilpaint image (image looks like oil painting)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="opacityImage"></a> <font size="-1">opacityImage</font></center>
      </td>
      <td><font size="-1">size_t opacity_</font></td>
      <td><font size="-1">Set or attenuate the opacity channel in the
image. If the image pixels are opaque then they are set to the specified
opacity value, otherwise they are blended with the supplied opacity
value.&#160; The value of opacity_ ranges from 0 (completely opaque) to <i>QuantumRange</i>.
The defines <i>OpaqueOpacity</i> and <i>TransparentOpacity</i> are
available to specify completely opaque or completely transparent,
respectively.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="opaqueImage"></a> <font size="-1">opaqueImage</font></center>
      </td>
      <td><font size="-1">const <a href="Color.html">Color</a>
&amp;opaqueColor_, const <a href="Color.html">Color</a> &amp;penColor_</font></td>
      <td><font size="-1">Change color of pixels matching opaqueColor_
to specified  penColor_.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="quantizeImage"></a> <font size="-1">quantizeImage</font></center>
      </td>
      <td><font size="-1">bool measureError_ = false</font></td>
      <td><font size="-1">Quantize image (reduce number of colors). Set
measureError_ to true in order to calculate error attributes.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="raiseImage"></a> <font size="-1">raiseImage</font></center>
      </td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;geometry_ = "6x6+0+0",&#160; bool raisedFlag_ =&#160; false</font></td>
      <td><font size="-1">Raise image (lighten or darken the edges of
an image  to give a 3-D raised or lowered effect)</font></td>
    </tr>
    <tr>
      <td rowspan="2">
      <center><a name="reduceNoiseImage"></a> <font size="-1">reduceNoise-</font> <br />
      <font size="-1">Image</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td rowspan="2"><font size="-1">Reduce noise in image using a
noise peak  elimination filter.</font></td>
    </tr>
    <tr>
      <td><font size="-1">size_t order_</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="rollImage"></a> <font size="-1">rollImage</font></center>
      </td>
      <td><font size="-1">int columns_, ssize_t rows_</font></td>
      <td><font size="-1">Roll image (rolls image vertically and
horizontally) by specified number of columnms and rows)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="rotateImage"></a> <font size="-1">rotateImage</font></center>
      </td>
      <td><font size="-1">double degrees_</font></td>
      <td><font size="-1">Rotate image counter-clockwise by specified
number of degrees</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="sampleImage"></a> <font size="-1">sampleImage</font></center>
      </td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;geometry_&#160;</font></td>
      <td><font size="-1">Resize image by using pixel sampling algorithm</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="scaleImage"></a> <font size="-1">scaleImage</font></center>
      </td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;geometry_</font></td>
      <td><font size="-1">Resize image by using simple ratio algorithm</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="segmentImage"></a> <font size="-1">segmentImage</font></center>
      </td>
      <td><font size="-1">double clusterThreshold_ = 1.0,</font> <br />
      <font size="-1">double smoothingThreshold_ = 1.5</font></td>
      <td><font size="-1">Segment (coalesce similar image components)
by analyzing  the histograms of the color components and identifying
units that are homogeneous  with the fuzzy c-means technique. Also uses <i>quantizeColorSpace</i>
and <i>verbose</i> image attributes. Specify <i>clusterThreshold_</i> ,
as the number&#160; of&#160; pixels&#160; each cluster&#160; must exceed
the cluster threshold to be considered valid. <i>SmoothingThreshold_</i>
eliminates noise in the&#160; second derivative of the histogram. As the
value is&#160; increased, you can&#160; expect&#160; a&#160; smoother
second derivative.&#160; The default is 1.5.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="shadeImage"></a> <font size="-1">shadeImage</font></center>
      </td>
      <td><font size="-1">double azimuth_ = 30, double elevation_ = 30,</font> <br />
      <font size="-1">bool colorShading_ = false</font></td>
      <td><font size="-1">Shade image using distant light source.
Specify <i> azimuth_</i> and <i>elevation_</i> as the&#160;
position&#160; of&#160; the light source. By default, the shading
results as a grayscale image.. Set c<i>olorShading_</i> to <i>true</i> to
shade the red, green, and blue components of the image.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="sharpenImage"></a> <font size="-1">sharpenImage</font></center>
      </td>
      <td><font size="-1">const double radius_ = 1, const double sigma_
= 0.5</font></td>
      <td><font size="-1">Sharpen pixels in image. The radius_
parameter specifies  the radius of the Gaussian, in pixels, not counting
the center pixel.&#160;  The sigma_ parameter specifies the standard
deviation of the Laplacian, in pixels.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="shaveImage"></a> <font size="-1">shaveImage</font></center>
      </td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;geometry_</font></td>
      <td><font size="-1">Shave pixels from image edges.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="shearImage"></a> <font size="-1">shearImage</font></center>
      </td>
      <td><font size="-1">double xShearAngle_, double yShearAngle_</font></td>
      <td><font size="-1">Shear image (create parallelogram by sliding
image by X or Y axis).&#160; Shearing slides one edge of an image along
the X&#160;  or&#160; Y axis,&#160; creating&#160; a
parallelogram.&#160; An X direction  shear slides an edge along the X
axis, while&#160; a&#160; Y&#160; direction  shear&#160; slides&#160; an
edge along the Y axis.&#160; The amount of the shear is controlled by a
shear angle.&#160; For X direction&#160; shears,&#160;  x&#160; degrees
is measured relative to the Y axis, and similarly, for Y direction
shears&#160; y&#160; degrees is measured relative to the X axis. Empty
triangles left over from shearing the&#160; image&#160; are filled&#160;
with&#160; the&#160; color&#160; defined as <i>borderColor</i>.&#160;</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="solarizeImage"></a> <font size="-1">solarizeImage</font></center>
      </td>
      <td><font size="-1">double factor_</font></td>
      <td><font size="-1">Solarize image (similar to effect seen when
exposing a photographic film to light during the development process)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="spreadImage"></a> <font size="-1">spreadImage</font></center>
      </td>
      <td><font size="-1">size_t amount_ = 3</font></td>
      <td><font size="-1">Spread pixels randomly within image by
specified amount</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="steganoImage"></a> <font size="-1">steganoImage</font></center>
      </td>
      <td><font size="-1">const <a href="Image.html">Image</a>
&amp;watermark_</font></td>
      <td><font size="-1">Add a digital watermark to the image (based
on second  image)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="stereoImage"></a> <font size="-1">stereoImage</font></center>
      </td>
      <td><font size="-1">const <a href="Image.html">Image</a>
&amp;rightImage_</font></td>
      <td><font size="-1">Create an image which appears in stereo when
viewed with red-blue glasses (Red image on left, blue on right)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="swirlImage"></a> <font size="-1">swirlImage</font></center>
      </td>
      <td><font size="-1">double degrees_</font></td>
      <td><font size="-1">Swirl image (image pixels are rotated by
degrees)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="textureImage"></a> <font size="-1">textureImage</font></center>
      </td>
      <td><font size="-1">const <a href="Image.html">Image</a>
&amp;texture_</font></td>
      <td><font size="-1">Layer a texture on image background</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="thresholdImage"></a> <font size="-1">thresholdImage</font></center>
      </td>
      <td><font size="-1">double threshold_</font></td>
      <td><font size="-1">Threshold image</font></td>
    </tr>
    <tr>
      <td rowspan="2">
      <center><a name="transformImage"></a> <font size="-1">transformImage</font></center>
      </td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;imageGeometry_</font></td>
      <td rowspan="2"><font size="-1">Transform image based on image
and crop geometries. Crop geometry is optional.</font></td>
    </tr>
    <tr>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;imageGeometry_, const <a href="Geometry.html">Geometry</a>
&amp;cropGeometry_&#160;</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="transparentImage"></a> <font size="-1">transparentImage</font></center>
      </td>
      <td><font size="-1">const <a href="Color.html">Color</a>
&amp;color_</font></td>
      <td><font size="-1">Add matte image to image, setting pixels
matching color  to transparent.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="trimImage"></a> <font size="-1">trimImage</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td><font size="-1">Trim edges that are the background color from
the image.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="waveImage"></a> <font size="-1">waveImage</font></center>
      </td>
      <td><font size="-1">double amplitude_ = 25.0, double wavelength_
= 150.0</font></td>
      <td><font size="-1">Alter an image along a sine wave.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="zoomImage"></a> <font size="-1">zoomImage</font></center>
      </td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;geometry_</font></td>
      <td><font size="-1">Zoom image to specified size.</font></td>
    </tr>
  </tbody>
</table></ul>
</p>
<p>Function objects are available to set attributes on image frames
which are equivalent to methods in the Image object. These function
objects allow setting an option across a range of image frames using f<tt>
or_each()</tt>. </p>
<p>The following code is an example of how the color 'red' may be set
to transparent in a GIF animation: </p>
<pre class="code">
list&lt;image> images; 
readImages( &amp;images, "animation.gif" ); 
for_each ( images.begin(), images.end(), transparentImage( "red" )  ); 
writeImages( images.begin(), images.end(), "animation.gif" );
</pre>
<p>The available function objects for setting image attributes are <br />
&#160;
<ul><table border="1">
  <caption style="font-weight: bold;">Image Attributes</caption> <tbody>
    <tr>
      <td>
      <center><b>Attribute</b></center>
      </td>
      <td>
      <center><b>Type</b></center>
      </td>
      <td>
      <center><b>Constructor Signature(s)</b></center>
      </td>
      <td>
      <center><b>Description</b></center>
      </td>
    </tr>
    <tr>
      <td>
      <center><a name="adjoinImage"></a> <font size="-1">adjoinImage</font></center>
      </td>
      <td><font size="-1">bool</font></td>
      <td><font size="-1">bool flag_</font></td>
      <td><font size="-1">Join images into a single multi-image file.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="antiAlias"></a> <font size="-1">antiAliasImage</font></center>
      </td>
      <td><font size="-1">bool</font></td>
      <td><font size="-1">bool flag_</font></td>
      <td><font size="-1">Control antialiasing of rendered Postscript
and Postscript  or TrueType fonts. Enabled by default.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="animationDelay"></a> <font size="-1">animation-</font> <br />
      <font size="-1">DelayImage</font></center>
      </td>
      <td><font size="-1">size_t (0 to 65535)</font></td>
      <td><font size="-1">size_t delay_</font></td>
      <td><font size="-1">Time in 1/100ths of a second (0 to 65535)
which must  expire before displaying the next image in an animated
sequence. This option  is useful for regulating the animation of a
sequence&#160; of GIF images within Netscape.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="animationIterations"></a> <font size="-1">animation-</font> <br />
      <font size="-1">IterationsImage</font></center>
      </td>
      <td><font size="-1">size_t</font></td>
      <td><font size="-1">size_t iterations_</font></td>
      <td><font size="-1">Number of iterations to loop an animation
(e.g. Netscape  loop extension) for.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="backgroundColor"></a> <font size="-1">background-</font> <br />
      <font size="-1">ColorImage</font></center>
      </td>
      <td><font size="-1"><a href="Color.html">Color</a> </font></td>
      <td><font size="-1">const <a href="Color.html">Color</a>
&amp;color_</font></td>
      <td><font size="-1">Image background color</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="backgroundTexture"></a> <font size="-1">background-</font> <br />
      <font size="-1">TextureImage</font></center>
      </td>
      <td><font size="-1">std::string</font></td>
      <td><font size="-1">const string &amp;texture_</font></td>
      <td><font size="-1">Image to use as background texture.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="borderColor"></a> <font size="-1">borderColor-</font> <br />
      <font size="-1">Image</font></center>
      </td>
      <td><font size="-1"><a href="Color.html">Color</a> </font></td>
      <td><font size="-1">&#160;const <a href="Color.html">Color</a>
&amp;color_</font></td>
      <td><font size="-1">Image border color</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="boxColor"></a> <font size="-1">boxColorImage</font></center>
      </td>
      <td><font size="-1"><a href="Color.html">Color</a> </font></td>
      <td><font size="-1">const <a href="Color.html">Color</a>
&amp;boxColor_</font></td>
      <td><font size="-1">Base color that annotation text is rendered
on.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="chromaBluePrimary"></a> <font size="-1">chroma-</font> <br />
      <font size="-1">BluePrimaryImage</font></center>
      </td>
      <td><font size="-1">double x &amp; y</font></td>
      <td><font size="-1">double x_, double y_</font></td>
      <td><font size="-1">Chromaticity blue primary point (e.g. x=0.15,
y=0.06)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="chromaGreenPrimary"></a> <font size="-1">chroma-</font> <br />
      <font size="-1">GreenPrimaryImage</font></center>
      </td>
      <td><font size="-1">double x &amp; y</font></td>
      <td><font size="-1">double x_, double y_</font></td>
      <td><font size="-1">Chromaticity green primary point (e.g. x=0.3,
y=0.6)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="chromaRedPrimary"></a> <font size="-1">chroma-</font> <br />
      <font size="-1">RedPrimaryImage</font></center>
      </td>
      <td><font size="-1">double x &amp; y</font></td>
      <td><font size="-1">double x_, double y_</font></td>
      <td><font size="-1">Chromaticity red primary point (e.g. x=0.64,
y=0.33)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="chromaWhitePoint"></a> <font size="-1">chroma-</font> <br />
      <font size="-1">WhitePointImage</font></center>
      </td>
      <td><font size="-1">double x &amp; y</font></td>
      <td><font size="-1">double x_, double y_</font></td>
      <td><font size="-1">Chromaticity white point (e.g. x=0.3127,
y=0.329)</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="colorFuzz"></a> <font size="-1">colorFuzzImage</font></center>
      </td>
      <td><font size="-1">double</font></td>
      <td><font size="-1">double fuzz_</font></td>
      <td><font size="-1">Colors within this distance are considered
equal. A number of algorithms search for a target&#160; color. By
default the color must be exact. Use this option to match colors that
are close to the target  color in RGB space.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="colorMap"></a> <font size="-1">colorMapImage</font></center>
      </td>
      <td><font size="-1"><a href="Color.html">Color</a> </font></td>
      <td><font size="-1">size_t index_, const <a
 href="Color.html">Color</a> &amp;color_</font></td>
      <td><font size="-1">Color at color-pallet index.</font></td>
    </tr>
    <tr>
      <td><a name="colorSpaceImage"></a> <font size="-1">colorSpaceImage</font></td>
      <td><font size="-1"><a href="Enumerations.html#ColorspaceType">ColorspaceType</a> </font></td>
      <td><font size="-1"><a href="Enumerations.html#ColorspaceType">ColorspaceType</a>
colorSpace_</font></td>
      <td><font size="-1">The colorspace (e.g. CMYK) used to represent
the image  pixel colors. Image pixels are always stored as RGB(A) except
for the case  of CMY(K).</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="composeImage"></a> <font size="-1">composeImage</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#CompositeOperator">CompositeOperator</a> </font></td>
      <td><font size="-1"><a href="Enumerations.html#CompositeOperator">CompositeOperator</a>
compose_</font></td>
      <td><font size="-1">Composition operator to be used when
composition is implicitly used (such as for image flattening).</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="compressType"></a> <font size="-1">compressType-</font> <br />
      <font size="-1">Image</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#CompressionType">CompressionType</a> </font></td>
      <td><font size="-1"><a href="Enumerations.html#CompressionType">CompressionType</a>
compressType_</font></td>
      <td><font size="-1">Image compresion type. The default is the
compression type of the specified image file.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="density"></a> <font size="-1">densityImage</font></center>
      </td>
      <td><font size="-1"><a href="Geometry.html">Geometry</a> &#160;
(default 72x72)</font></td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;density_</font></td>
      <td><font size="-1">Vertical and horizontal resolution in pixels
of the image. This option specifies an image density when decoding a
Postscript or Portable Document page. Often used with <i>psPageSize</i>.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="depth"></a> <font size="-1">depthImage</font></center>
      </td>
      <td><font size="-1">size_t (8 or 16)</font></td>
      <td><font size="-1">size_t depth_</font></td>
      <td><font size="-1">Image depth. Used to specify the bit depth
when reading  or writing&#160; raw images or thwn the output format
supports multiple depths. Defaults to the quantum depth that
ImageMagick is compiled with.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="endianImage"></a> <font size="-1">endianImage</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#EndianType">EndianType</a> </font></td>
      <td><font size="-1"><a href="Enumerations.html#EndianType">EndianType</a>
endian_</font></td>
      <td><font size="-1">Specify (or obtain) endian option for formats
which support it.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="fileName"></a> <font size="-1">fileNameImage</font></center>
      </td>
      <td><font size="-1">std::string</font></td>
      <td><font size="-1">const std::string &amp;fileName_</font></td>
      <td><font size="-1">Image file name.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="fillColorImage"></a> <font size="-1">fillColorImage</font></center>
      </td>
      <td><font size="-1">Color</font></td>
      <td><font size="-1">const Color &amp;fillColor_</font></td>
      <td><font size="-1">Color to use when filling drawn objects</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="filterType"></a> <font size="-1">filterTypeImage</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#FilterTypes">FilterTypes</a> </font></td>
      <td><font size="-1"><a href="Enumerations.html#FilterTypes">FilterTypes</a>
filterType_</font></td>
      <td><font size="-1">Filter to use when resizing image. The
reduction filter  employed has a sigificant effect on the time required
to resize an image and the resulting quality. The default filter is <i>Lanczos</i>
which has been shown to produce good results when reducing images.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="font"></a> <font size="-1">fontImage</font></center>
      </td>
      <td><font size="-1">std::string</font></td>
      <td><font size="-1">const std::string &amp;font_</font></td>
      <td><font size="-1">Text rendering font. If the font is a fully
qualified X server font name, the font is obtained from an X&#160;
server. To use a TrueType font, precede the TrueType filename with an @.
Otherwise, specify&#160;  a&#160; Postscript font name (e.g.
"helvetica").</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="fontPointsize"></a> <font size="-1">fontPointsize-</font> <br />
      <font size="-1">Image</font></center>
      </td>
      <td><font size="-1">size_t</font></td>
      <td><font size="-1">size_t pointSize_</font></td>
      <td><font size="-1">Text rendering font point size</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="gifDisposeMethod"></a> <font size="-1">gifDispose-</font> <br />
      <font size="-1">MethodImage</font></center>
      </td>
      <td><font size="-1">size_t</font> <br />
      <font size="-1">{ 0 = Disposal not specified,</font> <br />
      <font size="-1">1 = Do not dispose of graphic,</font> <br />
      <font size="-1">3 = Overwrite graphic with background color,</font> <br />
      <font size="-1">4 = Overwrite graphic with previous graphic. }</font></td>
      <td><font size="-1">size_t disposeMethod_</font></td>
      <td><font size="-1">layer disposal method. This option is used to
control how successive frames are rendered (how the preceding frame is
disposed of)  when creating a GIF animation.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="interlaceType"></a> <font size="-1">interlace-</font> <br />
      <font size="-1">TypeImage</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#InterlaceType">InterlaceType</a> </font></td>
      <td><font size="-1"><a href="Enumerations.html#InterlaceType">InterlaceType</a>
interlace_</font></td>
      <td><font size="-1">The type of interlacing scheme (default <i>NoInterlace</i>
). This option is used to specify the type of&#160; interlacing
scheme&#160; for&#160; raw&#160; image formats such as RGB or YUV. <i>NoInterlace</i>
means do not&#160; interlace, <i>LineInterlace</i> uses scanline
interlacing, and <i>PlaneInterlace</i> uses plane interlacing. <i>
PartitionInterlace</i> is like <i>PlaneInterlace</i> except the&#160;
different planes&#160; are  saved&#160; to individual files (e.g.&#160;
image.R, image.G, and image.B).  Use <i>LineInterlace</i> or <i>PlaneInterlace</i>
to create an interlaced  GIF or progressive JPEG image.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="isValidImage"></a> <font size="-1">isValidImage</font></center>
      </td>
      <td><font size="-1">bool</font></td>
      <td><font size="-1">bool isValid_</font></td>
      <td><font size="-1">Set image validity. Valid images become empty
(inValid) if argument is false.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="label"></a> <font size="-1">labelImage</font></center>
      </td>
      <td><font size="-1">std::string</font></td>
      <td><font size="-1">const std::string &amp;label_</font></td>
      <td><font size="-1">Image label</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="lineWidth"></a> <font size="-1">lineWidthImage</font></center>
      </td>
      <td><font size="-1">double</font></td>
      <td><font size="-1">double lineWidth_</font></td>
      <td><font size="-1">Line width for drawing lines, circles,
ellipses, etc.  See <a href="Drawable.html">Drawable</a> .</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="magick"></a> <font size="-1">magickImage</font></center>
      </td>
      <td><font size="-1">std::string</font></td>
      <td><font size="-1">&#160;const std::string &amp;magick_</font></td>
      <td><font size="-1">Get image format (e.g. "GIF")</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="matte"></a> <font size="-1">matteImage</font></center>
      </td>
      <td><font size="-1">bool</font></td>
      <td><font size="-1">bool matteFlag_</font></td>
      <td><font size="-1">True if the image has transparency. If set
True, store  matte channel if&#160; the image has one otherwise create
an opaque one.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="matteColor"></a> <font size="-1">matteColorImage</font></center>
      </td>
      <td><font size="-1"><a href="Color.html">Color</a> </font></td>
      <td><font size="-1">const <a href="Color.html">Color</a>
&amp;matteColor_</font></td>
      <td><font size="-1">Image matte (frame) color</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="monochrome"></a> <font size="-1">monochrome-</font> <br />
      <font size="-1">Image</font></center>
      </td>
      <td><font size="-1">bool</font></td>
      <td><font size="-1">bool flag_</font></td>
      <td><font size="-1">Transform the image to black and white</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="pageImage"></a> <font size="-1">pageImage</font></center>
      </td>
      <td><font size="-1"><a href="Geometry.html#PostscriptPageSize">Geometry</a> </font></td>
      <td><font size="-1">const <a
 href="Geometry.html#PostscriptPageSize">Geometry</a> &amp;pageSize_</font></td>
      <td><font size="-1">Preferred size and location of an image
canvas.</font>
      <p><font size="-1">Use this option to specify the dimensions and
position of the Postscript page in dots per inch or a TEXT page in
pixels. This option is typically used in concert with <i><a
 href="STL.html#density">density</a> </i>.</font> </p>
      <p><font size="-1">Page may also be used to position a GIF image
(such as for a scene in an animation)</font></p>
      </td>
    </tr>
    <tr>
      <td>
      <center><a name="penColor"></a> <font size="-1">penColorImage</font></center>
      </td>
      <td><font size="-1"><a href="Color.html">Color</a> </font></td>
      <td><font size="-1">const <a href="Color.html">Color</a>
&amp;penColor_</font></td>
      <td><font size="-1">Pen color to use when annotating on or
drawing on image.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="penTexture"></a> <font size="-1">penTextureImage</font></center>
      </td>
      <td><font size="-1"><a href="Image.html">Image</a> </font></td>
      <td><font size="-1">const Image &amp; penTexture_</font></td>
      <td><font size="-1">Texture image to paint with (similar to
penColor).</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="pixelColor"></a> <font size="-1">pixelColorImage</font></center>
      </td>
      <td><font size="-1"><a href="Color.html">Color</a> </font></td>
      <td><font size="-1">size_t x_, size_t y_, const <a
 href="Color.html"> Color</a> &amp;color_</font></td>
      <td><font size="-1">Get/set pixel color at location x &amp; y.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="psPageSize"></a> <font size="-1">psPageSizeImage</font></center>
      </td>
      <td><font size="-1"><a href="Geometry.html#PostscriptPageSize">Geometry</a> </font></td>
      <td><font size="-1">const <a
 href="Geometry.html#PostscriptPageSize">Geometry</a> &amp;pageSize_</font></td>
      <td><font size="-1">Postscript page size. Use this&#160; option
to specify  the dimensions&#160; of the Postscript page in dots per inch
or a TEXT page in pixels. This option is typically used in concert with <i>density</i>.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="quality"></a> <font size="-1">qualityImage</font></center>
      </td>
      <td><font size="-1">size_t (0 to 100)</font></td>
      <td><font size="-1">size_t quality_</font></td>
      <td><font size="-1">JPEG/MIFF/PNG compression level (default 75).</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="quantizeColors"></a> <font size="-1">quantize-</font> <br />
      <font size="-1">ColorsImage</font></center>
      </td>
      <td><font size="-1">size_t</font></td>
      <td><font size="-1">size_t colors_</font></td>
      <td><font size="-1">Preferred number of colors in the image. The
actual number of colors in the image may be less than your request, but
never more. Images with less unique colors than specified with this
option will have any duplicate or unused colors removed.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="quantizeColorSpace"></a> <font size="-1">quantize-</font> <br />
      <font size="-1">ColorSpaceImage</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#ColorspaceType">ColorspaceType</a> </font></td>
      <td><font size="-1"><a href="Enumerations.html#ColorspaceType">ColorspaceType</a>
colorSpace_</font></td>
      <td><font size="-1">Colorspace to quantize colors in (default
RGB). Empirical  evidence suggests that distances in color spaces such
as YUV or YIQ correspond  to perceptual color differences more closely
than do distances in RGB space.  These color spaces may give better
results when color reducing an image.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="quantizeDither"></a> <font size="-1">quantize-</font> <br />
      <font size="-1">DitherImage</font></center>
      </td>
      <td><font size="-1">bool</font></td>
      <td><font size="-1">bool flag_</font></td>
      <td><font size="-1">Apply Floyd/Steinberg error diffusion to the
image. The basic strategy of dithering is to&#160; trade&#160; intensity
resolution&#160; for&#160; spatial&#160; resolution&#160; by&#160;
averaging the intensities&#160;  of&#160; several&#160;
neighboring&#160; pixels. Images which&#160; suffer&#160;  from&#160;
severe&#160; contouring&#160; when&#160; reducing colors can be improved
with this option. The quantizeColors or monochrome option must be set
for this option to take effect.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="quantizeTreeDepth"></a> <font size="-1">quantize-</font> <br />
      <font size="-1">TreeDepthImage</font></center>
      </td>
      <td><font size="-1">size_t (0 to 8)</font></td>
      <td><font size="-1">size_t treeDepth_</font></td>
      <td><font size="-1">Depth of the quantization color
classification tree.  Values of 0 or 1 allow selection of the optimal
tree depth for the color reduction algorithm. Values between 2 and 8 may
be used to manually adjust the tree depth.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="renderingIntent"></a> <font size="-1">rendering-</font> <br />
      <font size="-1">IntentImage</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#RenderingIntent">RenderingIntent</a> </font></td>
      <td><font size="-1"><a href="Enumerations.html#RenderingIntent">RenderingIntent</a>
render_</font></td>
      <td><font size="-1">The type of rendering intent</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="resolutionUnits"></a> <font size="-1">resolution-</font> <br />
      <font size="-1">UnitsImage</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#ResolutionType">ResolutionType</a> </font></td>
      <td><font size="-1"><a href="Enumerations.html#ResolutionType">ResolutionType</a>
units_</font></td>
      <td><font size="-1">Units of image resolution</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="scene"></a> <font size="-1">sceneImage</font></center>
      </td>
      <td><font size="-1">size_t</font></td>
      <td><font size="-1">size_t scene_</font></td>
      <td><font size="-1">Image scene number</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="size"></a> <font size="-1">sizeImage</font></center>
      </td>
      <td><font size="-1"><a href="Geometry.html">Geometry</a> </font></td>
      <td><font size="-1">const <a href="Geometry.html">Geometry</a>
&amp;geometry_</font></td>
      <td><font size="-1">Width and height of a raw image (an image
which does  not support width and height information).&#160; Size may
also be used to affect the image size read from a multi-resolution
format (e.g. Photo CD, JBIG, or JPEG.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="stripImage"></a> <font size="-1">stripImage</font></center>
      </td>
      <td><font size="-1">void</font></td>
      <td><font size="-1">strips an image of all profiles and comments.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="strokeColorImage"></a> <font size="-1">strokeColorImage</font></center>
      </td>
      <td><font size="-1"><a href="Color.html">Color</a> </font></td>
      <td><font size="-1">const <a href="Color.html">Color</a>
&amp;strokeColor_</font></td>
      <td><font size="-1">Color to use when drawing object outlines</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="subImage"></a> <font size="-1">subImageImage</font></center>
      </td>
      <td><font size="-1">size_t</font></td>
      <td><font size="-1">size_t subImage_</font></td>
      <td><font size="-1">Subimage of an image sequence</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="subRange"></a> <font size="-1">subRangeImage</font></center>
      </td>
      <td><font size="-1">size_t</font></td>
      <td><font size="-1">size_t subRange_</font></td>
      <td><font size="-1">Number of images relative to the base image</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="tileName"></a> <font size="-1">tileNameImage</font></center>
      </td>
      <td><font size="-1">std::string</font></td>
      <td><font size="-1">const std::string &amp;tileName_</font></td>
      <td><font size="-1">Tile name</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="typeImage"></a> <font size="-1">typeImage</font></center>
      </td>
      <td><font size="-1"><a href="Enumerations.html#ImageType">ImageType</a> </font></td>
      <td><font size="-1"><a href="Enumerations.html#ImageType">ImageType</a>
type_</font></td>
      <td><font size="-1">Image storage type.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="verbose"></a> <font size="-1">verboseImage</font></center>
      </td>
      <td><font size="-1">bool</font></td>
      <td><font size="-1">bool verboseFlag_</font></td>
      <td><font size="-1">Print detailed information about the image</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="view"></a> <font size="-1">viewImage</font></center>
      </td>
      <td><font size="-1">std::string</font></td>
      <td><font size="-1">const std::string &amp;view_</font></td>
      <td><font size="-1">FlashPix viewing parameters.</font></td>
    </tr>
    <tr>
      <td>
      <center><a name="x11Display"></a> <font size="-1">x11DisplayImage</font></center>
      </td>
      <td><font size="-1">std::string (e.g. "hostname:0.0")</font></td>
      <td><font size="-1">const std::string &amp;display_</font></td>
      <td><font size="-1">X11 display to display to, obtain fonts from,
or to capture image from</font></td>
    </tr>
  </tbody>
</table></ul>
<br />
&#160; </p>
<center>
<h3> Query Image Format Support</h3>
</center>
<p>Magick++ provides the&#160;<a name="coderInfoList"></a> <i>coderInfoList()</i>
function to support obtaining information about the image formats
supported by ImageMagick. Support for image formats in ImageMagick
is provided by modules known as "coders". A user-provided container is
updated based on a boolean truth-table match. The truth-table supports
matching based on whether ImageMagick can read the format, write the
format, or supports multiple frames for the format. A wildcard specifier
is supported for any "don't care" field. The data obtained via
coderInfoList() may be useful for preparing GUI dialog boxes or for
deciding which output format to write based on support within the
ImageMagick build.</p>
<p>The definition of coderInfoList is: </p>
<pre class="code">
class CoderInfo 
  { 
  public:

    enum MatchType { 
      AnyMatch,  // match any coder 
      TrueMatch, // match coder if true 
      FalseMatch // match coder if false 
    };

    [ remaining CoderInfo methods ]

   }

  template &lt;class Container > 
  void coderInfoList( Container *container_, 
                      CoderInfo::MatchType isReadable_   = CoderInfo::AnyMatch, 
                      CoderInfo::MatchType isWritable_   = CoderInfo::AnyMatch, 
                      CoderInfo::MatchType isMultiFrame_ = CoderInfo::AnyMatch 
                      );
</pre>
<p>The following example shows how to retrieve a list of all of the
coders which support reading images and print the coder attributes (all
listed formats will be readable): </p>
<pre class="code">
  list&lt;CoderInfo> coderList; 
  coderInfoList( &amp;coderList,           // Reference to output list 
                 CoderInfo::TrueMatch, // Match readable formats 
                 CoderInfo::AnyMatch,  // Don't care about writable formats 
                 CoderInfo::AnyMatch); // Don't care about multi-frame support 
  list&lt;CoderInfo>::iterator entry = coderList.begin(); 
  while( entry != coderList.end() ) 
  { 
    cout &lt;&lt; entry->name() &lt;&lt; ": (" &lt;&lt; entry->description() &lt;&lt; ") : "; 
    cout &lt;&lt; "Readable = "; 
    if ( entry->isReadable() ) 
      cout &lt;&lt; "true"; 
    else 
      cout &lt;&lt; "false"; 
    cout &lt;&lt; ", "; 
    cout &lt;&lt; "Writable = "; 
    if ( entry->isWritable() ) 
      cout &lt;&lt; "true"; 
    else 
      cout &lt;&lt; "false"; 
    cout &lt;&lt; ", "; 
    cout &lt;&lt; "Multiframe = "; 
    if ( entry->isMultiframe() ) 
      cout &lt;&lt; "true"; 
    else 
      cout &lt;&lt; "false"; 
    cout &lt;&lt; endl;
    entry ++;
   } 
</pre>
<tt><font color="#000066">&#160;&#160; }</font></tt>&#160;<!-- p -->
<h3 style="text-align: center;">Obtaining A Color Histogram&#160; </h3>
<p>Magick++ provides the <a name="colorHistogram"></a><span
 style="font-weight: bold;">colorHistogram</span> template function to
retrieve a color histogram from an image. A color histogram provides a
count of how many times each color occurs in the image. The histogram is
written into a user-provided container, which (for example) could be a <span
 style="font-style: italic;">&lt;vector&gt;</span> or a <span
 style="font-style: italic;">&lt;map&gt;</span>. &#160;When a
&lt;map&gt; is used, the <span style="font-style: italic;">Color</span>
is used as the key so that quick lookups of usage counts for colors may
be performed. Writing into a <span style="font-style: italic;">&lt;map&gt;</span>
may be slower than writing into a <span style="font-style: italic;">&lt;vector&gt;</span>
since the <span style="font-style: italic;">&lt;map&gt;</span> sorts the
entries (by color intensity) and checks for uniqueness. Each histogram
entry is contained in type&#160;<span style="font-style: italic;">std::pair&lt;Magick::Color,unsigned
long&gt;</span><span style="font-style: italic;"> </span>with the first
member of the pair being a <span style="font-style: italic;">Color,</span>
and the second member of the pair being an '<span
 style="font-style: italic;">unsigned long</span>'. Use the <span
 style="font-style: italic;">&lt;pair&gt;</span> "<span
 style="font-style: italic;">first</span>" member to access the Color
and the "<span style="font-style: italic;">second</span>" member to
access&#160;the number of times the color occurs in the image.</p>
<p>The template function declaration is as follows:<br />
</p>
<pre class="code">
template &lt;class Container >
void colorHistogram( Container *histogram_, const Image image)
</pre>
<p>The following examples illustrate using both a &lt;map&gt; and a
&lt;vector&gt; to retrieve the color histogram, and print out a
formatted summary.<br />
<br />
Using &lt;map&gt;:<br />
&#160; &#160; <br />
<pre class="code">
  Image image("image.miff");
  map&lt;Color,unsigned long> histogram;
  colorHistogram( &amp;histogram, image );
  std::map&lt;Color,unsigned long>::const_iterator p=histogram.begin();
  while (p != histogram.end())
    {
      cout &lt;&lt; setw(10) &lt;&lt; (int)p->second &lt;&lt; ": ("
           &lt;&lt; setw(quantum_width) &lt;&lt; (int)p->first.redQuantum() &lt;&lt; ","
           &lt;&lt; setw(quantum_width) &lt;&lt; (int)p->first.greenQuantum() &lt;&lt; ","
           &lt;&lt; setw(quantum_width) &lt;&lt; (int)p->first.blueQuantum() &lt;&lt; ")"
           &lt;&lt; endl;
       p++;
    }
</pre>
<br />
Using &lt;vector&gt;:<br />
&#160; &#160; <br />
<pre class="code">
  Image image("image.miff");
  std::vector&lt;std::pair&lt;Color,unsigned long> > histogram;
  colorHistogram( &amp;histogram, image );
  std::vector&lt;std::pair&lt;Color,unsigned long> >::const_iterator p=histogram.begin();
  while (p != histogram.end())
    {
      cout &lt;&lt; setw(10) &lt;&lt; (int)p->second &lt;&lt; ": ("
           &lt;&lt; setw(quantum_width) &lt;&lt; (int)p->first.redQuantum() &lt;&lt; ","
           &lt;&lt; setw(quantum_width) &lt;&lt; (int)p->first.greenQuantum() &lt;&lt; ","
           &lt;&lt; setw(quantum_width) &lt;&lt; (int)p->first.blueQuantum() &lt;&lt; ")"
           &lt;&lt; endl;
      p++;
    }
</pre>
</p>
</div>
</body>
</html>
